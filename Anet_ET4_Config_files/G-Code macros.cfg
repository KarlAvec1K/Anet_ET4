
#   _  __          _                      __ _      
#  | |/ /         | |   /\               /_ | |     
#  | ' / __ _ _ __| |  /  \__   _____  ___| | | __  
#  |  < / _` | '__| | / /\ \ \ / / _ \/ __| | |/ /  
#  | . \ (_| | |  | |/ ____ \ V /  __/ (__| |   <   
#  |_|\_\__,_|_|  |_/_/    \_\_/ \___|\___|_|_|\_\  
#  https://github.com/KarlAvec1K/anet-et4
#           _   _ ______ _______   ______ _______ _  _     _  ___      _____ _____  _____  ______ _____  
#     /\   | \ | |  ____|__   __| |  ____|__   __| || |   | |/ / |    |_   _|  __ \|  __ \|  ____|  __ \ 
#    /  \  |  \| | |__     | |    | |__     | |  | || |_  | ' /| |      | | | |__) | |__) | |__  | |__) |
#   / /\ \ | . ` |  __|    | |    |  __|    | |  |__   _| |  < | |      | | |  ___/|  ___/|  __| |  _  / 
#  / ____ \| |\  | |____   | |    | |____   | |     | |   | . \| |____ _| |_| |    | |    | |____| | \ \ 
# /_/    \_\_| \_|______|  |_|    |______|  |_|     |_|   |_|\_\______|_____|_|    |_|    |______|_|  \_\

# This file contains common pin mappings and configuration for the Anet ET4 printer for klipper.

# Copyright (C) 2023 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original inspiration:
# https://gist.github.com/ChipCE/95fdbd3c2f3a064397f9610f915f7d02

[gcode_macro bed_mesh_calibrate_fast]
description: Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
  Usage: See Klipper documentation.
gcode:
  # Abort on a bad config.
  BED_MESH_CHECK ABORT=1

  # Find the real bed_mesh_calibrate command.
  {% set calibrate_cmd =
           (printer["gcode_macro list_macros"].macros.bed_mesh_calibrate|
              default(["bed_mesh_calibrate"],True))[-1] %}

  {% set km = printer["gcode_macro _km_globals"] %}
  {% set probe_mesh_padding = km.probe_mesh_padding %}
  {% set probe_min_count = km.probe_min_count %}
  {% set probe_count_scale = km.probe_count_scale %}
  {% set bed_mesh = printer.configfile.settings.bed_mesh %}

  # TODO: Handle the math for a delta bed.
  {%if "mesh_radius" not in bed_mesh and
       "MESH_RADIUS" not in params %}
    {% set safe_min_x = bed_mesh.mesh_min[0] %}
    {% set safe_min_y = bed_mesh.mesh_min[1] %}
    {% set safe_max_x = bed_mesh.mesh_max[0] %}
    {% set safe_max_y = bed_mesh.mesh_max[1] %}

    # Always bound MESH_MIN and MESH_MAX.
    {% if "MESH_MIN" in params %}
      {% set mesh_min_x = (params.MESH_MIN.split(",")[0]|float -
                           probe_mesh_padding, safe_min_x)|max %}
      {% set mesh_min_y = (params.MESH_MIN.split(",")[1]|float -
                           probe_mesh_padding, safe_min_y)|max %}
    {% else %}
      {% set mesh_min_x = safe_min_x %}
      {% set mesh_min_y = safe_min_y %}
    {% endif %}
    {% if "MESH_MAX" in params %}
      {% set mesh_max_x = (params.MESH_MAX.split(",")[0]|float +
                           probe_mesh_padding, safe_max_x)|min %}
      {% set mesh_max_y = (params.MESH_MAX.split(",")[1]|float +
                           probe_mesh_padding, safe_max_y)|min %}
    {% else %}
      {% set mesh_max_x = safe_max_x %}
      {% set mesh_max_y = safe_max_y %}
    {% endif %}

    {% set probe_count = bed_mesh.probe_count if not params.PROBE_COUNT else
                         params.PROBE_COUNT.split(",")|map('int')|list %}
    # Don't scale the probe count if one was explicitly provided.
    {% if "PROBE_COUNT" not in params %}
      {% set max_x_probes = probe_count[0] %}
      {% set max_y_probes = probe_count[-1] %}

      {% set x_probes = (max_x_probes * (mesh_max_x - mesh_min_x) /
                         (safe_max_x - safe_min_x) * probe_count_scale)
                        | round(0) | int %}
      {% set x_probes = ((x_probes, probe_min_count)|max, max_x_probes)|min %}

      {% set y_probes = (max_y_probes * (mesh_max_y - mesh_min_y ) /
                         (safe_max_y - safe_min_y) * probe_count_scale )
                        | round(0) | int %}
      {% set y_probes = ((y_probes, probe_min_count)|max, max_y_probes)|min %}
      # Add probes for bicubic if one axis has too many probes for lagrange.
      {% if x_probes > 6 and y_probes < 4 %}
        {% set y_probes = 4 %}
      {% elif y_probes > 6 and x_probes < 4 %}
        {% set x_probes = 4 %}
      {% endif %}
      {% set probe_count = [x_probes,y_probes] %}
    {% elif probe_count|length == 1 %}
      {% set dummy = probe_count.append(probe_count[0]) %}
    {% endif %}

    # If the config includes a relative_reference_index then we need to find the
    # point in the new mesh that's closest to the index point in the mesh that
    # the config would have generated.
    # TODO: Could also adjust the mesh parameters in here to ensure it includes
    # the original index point, but that would be extra work and would cause
    # slower probes if the mesh needs to be expanded to include the point.
    {% if "relative_reference_index" in bed_mesh %}
      {% set row = (bed_mesh.relative_reference_index / bed_mesh.probe_count[0]
                    )|int%}
      {% set rrf_x = (((safe_max_x - safe_min_x) /
                       (bed_mesh.probe_count[0] - 1))|round(2, 'floor')) *
                     (bed_mesh.relative_reference_index %
                      bed_mesh.probe_count[-1]) %}
      {% if row % 2 %}
        {% set rrf_x = safe_max_x - rrf_x %}
      {% else %}
        {% set rrf_x = safe_min_x + rrf_x %}
      {% endif %}
      {% set rrf_y = (((safe_max_y - safe_min_y) /
                       (bed_mesh.probe_count[-1] - 1))|round(2, 'floor')) *
                     row + safe_min_x %}
      {% set x_dist = (mesh_max_x - mesh_min_x) / (probe_count[0] - 1) %}
      {% set y_dist = (mesh_max_y - mesh_min_y) / (probe_count[1] - 1) %}
      {% set rrf = {'x':0, 'y':0, 'dist':safe_max_x**2+safe_max_y**2,'pos':0} %}
      {% for row in range(probe_count[1])%}
        {% for col in range(probe_count[0])%}
          {% if row % 2 %}
            {% set x = mesh_max_x - col * x_dist %}
          {% else %}
            {% set x = mesh_min_x + col * x_dist %}
          {% endif %}
          {% set y = mesh_min_y + row * y_dist %}
          {% set dist = ((x - rrf_x)**2 + (y - rrf_y)**2)**0.5 %}
          {% if dist < rrf.dist %}
            {% set dummy = rrf.__setitem__("dist", dist) %}
            {% set dummy = rrf.__setitem__("x", x) %}
            {% set dummy = rrf.__setitem__("y", y) %}
            {% set dummy = rrf.__setitem__("pos", row * probe_count[1] + col) %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% if rrf.x != rrf_x or rrf.y != rrf_y %}
        {action_respond_info("relative_reference_index remapped to"
                             " %d (%.2f,%.2f) from %d (%.2f,%.2f)" %
                             (rrf.pos, rrf.x, rrf.y,
                              bed_mesh.relative_reference_index, rrf_x, rrf_y))}
      {% endif %}
      {% set dummy = params.__setitem__("RELATIVE_REFERENCE_INDEX", rrf.pos) %}
    {% endif %}

    {% set dummy = params.__setitem__("MESH_MIN", mesh_min_x~","~mesh_min_y) %}
    {% set dummy = params.__setitem__("MESH_MAX", mesh_max_x~","~mesh_max_y) %}
    {% set dummy = params.__setitem__("PROBE_COUNT", probe_count|join(',')) %}
    # Force bicubic if we've exceeded the max for lagrange.
    {% if probe_count[0] > 6 or probe_count[1]|default(0) > 6 %}
      {% set dummy = params.__setitem__("ALGORITHM", "bicubic") %}
    {% endif %}
    # Warn on bad parameters that were fixed.
    {% if "MESH_MIN" in params or "MESH_MAX" in params %}
      BED_MESH_CHECK {rawparams}
    {% endif %}
  {% else %}
    # Mesh limits may be out of bounds, so strip them from the fallback path.
    {% set dummy = params.__delitem__("MESH_MIN") %}
    {% set dummy = params.__delitem__("MESH_MAX") %}
  {% endif %}
  # Abort on bad parameters.
  {% if "MESH_MIN" in params or "MESH_MAX" in params %}
    BED_MESH_CHECK ABORT=1{%for k in params%}{' '~k~'="'~params[k]~'"'}{%
                            endfor%}
  {% endif %}
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing
  {calibrate_cmd}{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro bed_mesh_check]
description: Warns if bed_mesh config may generate an invalid mesh.
  Usage: BED_MESH_CHECK [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [ABORT=<0|1>]
gcode:
  {% if printer.bed_mesh is defined %}
    {% set action = action_respond_info if params.ABORT|default(0)|int == 0 else
                    action_raise_error %}
    {% set settings = printer.configfile.settings %}
    {% set x_min = settings.stepper_x.position_min %}
    {% set y_min = settings.stepper_y.position_min %}
    {% set x_max = settings.stepper_x.position_max %}
    {% set y_max = settings.stepper_y.position_max %}

    {% set label = "[bed_mesh] config" %}
    {% if "MESH_MIN" in params %}
      {% set label = "BED_MESH_CALIBRATE params" %}
      {% set mesh_min_x = params.MESH_MIN.split(",")[0]|float %}
      {% set mesh_min_y = params.MESH_MIN.split(",")[1]|float %}
    {% else %}
      {% set mesh_min_x = settings.bed_mesh.mesh_min[0] %}
      {% set mesh_min_y = settings.bed_mesh.mesh_min[1] %}
    {% endif %}
    {% if "MESH_MAX" in params %}
      {% set label = "BED_MESH_CALIBRATE params" %}
      {% set mesh_max_x = params.MESH_MAX.split(",")[0]|float %}
      {% set mesh_max_y = params.MESH_MAX.split(",")[1]|float %}
    {% else %}
      {% set mesh_max_x = settings.bed_mesh.mesh_max[0] %}
      {% set mesh_max_y = settings.bed_mesh.mesh_max[1] %}
    {% endif %}

    {% if "bltouch" in settings %}
        {% set x_offset = settings.bltouch.x_offset %}
        {% set y_offset = settings.bltouch.y_offset %}
        {% set probe = "bltouch" %}
    {% elif "probe" in settings %}
        {% set x_offset = settings.probe.x_offset %}
        {% set y_offset = settings.probe.y_offset %}
        {% set probe = "probe" %}
    {% else %}
        {% set x_offset = 0.0 %}
        {% set y_offset = 0.0 %}
    {% endif %}

    {% set output = [] %}
    {% set warn =
         "* mesh_%s (%f, %f) adjusted by " ~ probe ~
         ".%s_offset (%f) can move out of range for "
         "stepper_%s.position_%s (%f)." %}
    {% if x_offset > 0 and (mesh_min_x - x_offset) < x_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'x', x_offset, 'x', 'min', x_min)) %}
    {% elif x_offset < 0 and (mesh_max_x - x_offset) > x_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'x', x_offset, 'x', 'max', x_max)) %}
    {% endif %}
    {% if y_offset > 0 and (mesh_min_y - y_offset) < y_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'y', y_offset, 'y', 'min', y_min)) %}
    {% elif y_offset < 0 and (mesh_max_y - y_offset) > y_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'y', y_offset, 'y', 'max', y_max)) %}
    {% endif %}

    {% if output %}
      { action(
        "Warning: The following issue(s) were detected in your " ~ label ~
        ":\n" ~ output|join("\n")) }
    {% endif %}
  {% endif %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original inspiration:
# https://klipper.discourse.group/t/saving-and-adjusting-per-build-surface-z-offsets/696 

[gcode_macro _apply_bed_surface_offset]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active %}
    SET_SURFACE_ACTIVE SURFACE={surfaces.active}
  {% endif %}

[gcode_macro _init_surfaces]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if "bed_surfaces" in printer.save_variables.variables %}
    {% set old_surfaces = printer.save_variables.variables.bed_surfaces %}
  {% else %}
    {% set old_surfaces = { 'active' : '', 'available' : {} } %}
  {% endif %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                        default(0.0)|float %}
  {% if 'endstop_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('endstop_z', new_endstop_z) %}
  {% endif %}
  {% if 'probe_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('probe_z', new_probe_z) %}
  {% endif %}
  {% set surfaces = { 'active' : '', 'available' : {},
                      'endstop_z' : old_surfaces.endstop_z,
                      'probe_z' : old_surfaces.probe_z } %}
  {% for s in km.bed_surfaces %}
    {% set s = s.split()|join(' ')|lower %}
    {% if s|length > km.bed_surface_max_name_length or
          s|list|select("in", " \r\n\"\'")|list %}
      {action_raise_error('Invalid surface name "%s". Name must be %d or fewer '
        'characters and must not include space or quotation characters'
        | format(s, km.bed_surface_max_name_length))}
    {% endif %}
    {% if s in old_surfaces.available %}
      {% set dummy = surfaces.available.__setitem__(s,
                       old_surfaces.available[s]) %}
    {% else %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : 0.0}) %}
    {% endif %}
  {% endfor %}
  {% if old_surfaces.active in surfaces.available %}
    {% set dummy = surfaces.__setitem__('active', old_surfaces.active) %}
  {% elif km.bed_surfaces %}
    {% set dummy = surfaces.__setitem__('active', km.bed_surfaces[0]|lower) %}
  {% endif %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
  _APPLY_BED_SURFACE_OFFSET
  {% if new_probe_z != surfaces.probe_z or
        new_endstop_z != surfaces.endstop_z %}
    { action_respond_info(
      'Z probe offset or endstop position changed. Run ADJUST_SURFACE_OFFSETS '
      'to adjust the offset for all saved surfaces by the change differential, '
      'or run ADJUST_SURFACE_OFFSETS IGNORE=1 to hide this message without '
      'making changes.') }
  {% endif %}

[gcode_macro adjust_surface_offsets]
description: Adjusts surface offsets to account for changes in the Z endstop
  position or probe Z offset.
  Usage: ADJUST_SURFACE_OFFSETS [IGNORE]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                          default(0.0)|float %}
  {% set diff = (surfaces.probe_z - new_probe_z +
                 surfaces.endstop_z - new_endstop_z)|round(6) %}
  {% if not params.IGNORE|default(0)|int %}
    {% for s in surfaces.available %}
      {% set offset = (surfaces.available[s].offset - diff)|round(6) %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : offset}) %}
    {% endfor %}
    { action_respond_info("All bed surfaces now adjusted by %1.4f"|
                          format(diff))}
  {% elif diff != 0 %}
    { action_respond_info("Status cleared without adjustment") }
  {% endif %}
  {% set dummy = surfaces.__setitem__('endstop_z', new_endstop_z| round(6)) %}
  {% set dummy = surfaces.__setitem__('probe_z', new_probe_z|round(6)) %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"

[gcode_macro set_surface_offset]
description: Sets the offset for a surface and moves the toolhead (if homed).
  Usage: SET_SURFACE_OFFSET [OFFSET=<offset>] [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE not in surfaces.available %}
    { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
  {% endif %}
  {% set active = surfaces.available[SURFACE] %}
  # If no offset is provided just print out the current offset.
  {% set OFFSET = params.OFFSET|default(active.offset)|float %}
  {% if OFFSET != active.offset %}
    {% set dummy = surfaces.available[SURFACE].__setitem__("offset", OFFSET) %}
    SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% if SURFACE == surfaces.active %}
      _km_set_gcode_offset_base Z="{OFFSET}" MOVE={
        1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
  {% endif %}
  { action_respond_info("Bed surface: %s Offset: %.3f"
                        | format(SURFACE, OFFSET)) }
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(active surface) %}
  {% set dummy = params.OFFSET|default(none)|float %}
  " %} # End argument block for Mainsail

[gcode_macro set_surface_active]
description: Sets the active bed surface and moves the toolhead (if homed). If
  no SURFACE argument is present the available surfaces are listed and the
  active one is preceded by a "*".
  Usage: SET_SURFACE_ACTIVE [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if "SURFACE" in params %}
    {% set SURFACE = params.SURFACE|lower %}
    {% if SURFACE not in surfaces.available %}
      { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
    {% endif %}
    {% if SURFACE != surfaces.active %}
      {% set dummy = surfaces.__setitem__("active", SURFACE) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
    {% if surfaces.available[SURFACE].offset !=
          printer.gcode_move.homing_origin.z %}
      _km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
        }" MOVE={1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
    {action_respond_info("Active bed surface: %s; offset: %.3f"
                        | format(SURFACE, surfaces.available[SURFACE].offset))}
  {% else %}
    {% set output = [] %}
    {% for s in surfaces.available|list|sort %}
      {% set dummy = output.append("%s&nbsp;%s - offset: %.3f" 
                      | format("*" if s == surfaces.active else "&nbsp;",
                                s, surfaces.available[s].offset)) %}
    {% endfor %}
    {action_respond_info(output|join('\n'))}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(none) %}
  " %} # End argument block for Mainsail

[gcode_macro set_gcode_offset]
description: Wraps SET_GCODE_OFFSET to update the current bed sheet offset.
  Usage: SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>]
                          [Y=<pos>|Y_ADJUST=<adjust>]
                          [Z=<pos>|Z_ADJUST=<adjust>]
                          [MOVE=1 [MOVE_SPEED=<speed>]]
rename_existing: _KM_SET_GCODE_OFFSET_BASE
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active and
        not printer["gcode_macro _km_save_state"].is_ephemeral %}
    {% set Z = params.Z|default(0.0)|float|round(6) %}
    {% set Z_ADJUST = params.Z_ADJUST|default(0.0)|float %}
    {% if 'Z' in params and
                 Z != surfaces.available[surfaces.active].offset %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__("offset",
                       Z) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% elif Z_ADJUST != 0.0 %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__(
        "offset", (Z_ADJUST + printer.gcode_move.homing_origin.z)|round(6)) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
  {% endif %}
  _km_set_gcode_offset_base{% for k in params%}{' '~k~'="'~params[k]~'"'
    }{% endfor %}

[gcode_macro make_surface_mesh]
description: Generates and saves a mesh to automatically load in PRINT_START.
  Usage: MAKE_SURFACE_MESH [SURFACE=<surface>] [BED=<probing temperature>]
                           [EXTRUDER=<probing temperature>]
                           [MESH_MULTIPLIER=<integer multiple of mesh density>]
                           [bed_mesh_calibrate parameters]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE not in surfaces.available %}
    { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
  {% endif %}
  {% set dummy = params.__setitem__('PROFILE', SURFACE) %}
  {% set BED = params.BED|default(70) | int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set EXTRUDER = params.EXTRUDER|default(km.start_extruder_probing_temp) |
                    int %}
  {% set MESH_MULTIPLIER = (params.MESH_MULTIPLIER|default(2)|int, 1)|max %}

  M104 S{EXTRUDER}
  M140 S{BED}
  G28

  # Adjust offset before running mesh
  {% if surfaces.available[SURFACE].offset !=
        printer.gcode_move.homing_origin.z %}
    _km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
      }" MOVE=1
  {% endif %}

  # If no offset is provided just print out the current offset.
  {% if BED > 0 %}
    {action_respond_info("Stabilizing bed at %iC" | format(BED,))}
    _KM_PARK_IF_NEEDED HEATER=heater_bed RANGE=0.5
    {% if BED < (printer.heater_bed.temperature - 0.2) %}
      M190 R{BED}
      G4 P{((km.start_bed_heat_delay * 10, 30000)|min,
            km.start_bed_heat_delay)|max}
    {% else %}
      G4 P{km.start_bed_heat_delay}
    {% endif %}
    M190 R{BED}
  {% endif %}

  {% if EXTRUDER > 0 %}
    _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
    M109 R{km.start_extruder_probing_temp}
  {% endif %}

  {% if km.start_home_z_at_temp and not bed_at_target %}
    G28 Z # Re-home only the Z axis now that the bed has stabilized.
  {% endif %}

  # Scale the mesh grid size while preserving the original points and relative
  # reference index.
  {% set probe_count = printer.configfile.settings.bed_mesh.probe_count
                         if not params.PROBE_COUNT else
                       params.PROBE_COUNT.split(",")|map('int')|list %}
  {% set dummy = params.__setitem__('PROBE_COUNT',(
                   MESH_MULTIPLIER * (probe_count[0] - 1) + 1,
                   MESH_MULTIPLIER * (probe_count[-1] - 1) + 1,)|join(',')) %}

  BED_MESH_CLEAR
  BED_MESH_CALIBRATE_FAST {%
    for k in params|reject('in',['BED','SURFACE'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %}
  SAVE_CONFIG

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.MESH_MULTIPLIER|default(2) %}
  {% set dummy = params.SURFACE|default(active surface) %}
  " %} # End argument block for Mainsail

[gcode_macro load_surface_mesh]
description: Attempts to load a mesh associated with the specified surface.
  Usage: LOAD_SURFACE_MESH [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE != surfaces.active %}
    SET_SURFACE_ACTIVE SURFACE={SURFACE}
  {% endif %}

  {% if SURFACE in printer.bed_mesh.profiles %}
    {% set mesh = printer.bed_mesh.profiles[SURFACE].mesh_params %}
    {% set default = printer.configfile.settings.bed_mesh %}
    # Ensure the saved mesh has at least the resolution of the default.
    {% if mesh.min_x <= (default.mesh_min[0] + 0.5) and
          mesh.min_y <= (default.mesh_min[1] + 0.5) and
          mesh.max_x >= (default.mesh_max[0] - 0.5) and
          mesh.max_y >= (default.mesh_max[1] - 0.5) and
          mesh.x_count >= default.probe_count[0] and
          mesh.y_count >= default.probe_count[-1] %}
      # Skip the bed level if we have a good profile.
      BED_MESH_PROFILE LOAD={SURFACE}
      {action_respond_info("Loaded mesh: %s" | format(SURFACE,))}
    {% endif %}
  {% endif %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original inspiration:
# https://klipper.discourse.group/t/saving-and-adjusting-per-build-surface-z-offsets/696 

[gcode_macro _apply_bed_surface_offset]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active %}
    SET_SURFACE_ACTIVE SURFACE={surfaces.active}
  {% endif %}

[gcode_macro _init_surfaces]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if "bed_surfaces" in printer.save_variables.variables %}
    {% set old_surfaces = printer.save_variables.variables.bed_surfaces %}
  {% else %}
    {% set old_surfaces = { 'active' : '', 'available' : {} } %}
  {% endif %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                        default(0.0)|float %}
  {% if 'endstop_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('endstop_z', new_endstop_z) %}
  {% endif %}
  {% if 'probe_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('probe_z', new_probe_z) %}
  {% endif %}
  {% set surfaces = { 'active' : '', 'available' : {},
                      'endstop_z' : old_surfaces.endstop_z,
                      'probe_z' : old_surfaces.probe_z } %}
  {% for s in km.bed_surfaces %}
    {% set s = s.split()|join(' ')|lower %}
    {% if s|length > km.bed_surface_max_name_length or
          s|list|select("in", " \r\n\"\'")|list %}
      {action_raise_error('Invalid surface name "%s". Name must be %d or fewer '
        'characters and must not include space or quotation characters'
        | format(s, km.bed_surface_max_name_length))}
    {% endif %}
    {% if s in old_surfaces.available %}
      {% set dummy = surfaces.available.__setitem__(s,
                       old_surfaces.available[s]) %}
    {% else %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : 0.0}) %}
    {% endif %}
  {% endfor %}
  {% if old_surfaces.active in surfaces.available %}
    {% set dummy = surfaces.__setitem__('active', old_surfaces.active) %}
  {% elif km.bed_surfaces %}
    {% set dummy = surfaces.__setitem__('active', km.bed_surfaces[0]|lower) %}
  {% endif %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
  _APPLY_BED_SURFACE_OFFSET
  {% if new_probe_z != surfaces.probe_z or
        new_endstop_z != surfaces.endstop_z %}
    { action_respond_info(
      'Z probe offset or endstop position changed. Run ADJUST_SURFACE_OFFSETS '
      'to adjust the offset for all saved surfaces by the change differential, '
      'or run ADJUST_SURFACE_OFFSETS IGNORE=1 to hide this message without '
      'making changes.') }
  {% endif %}

[gcode_macro adjust_surface_offsets]
description: Adjusts surface offsets to account for changes in the Z endstop
  position or probe Z offset.
  Usage: ADJUST_SURFACE_OFFSETS [IGNORE]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                          default(0.0)|float %}
  {% set diff = (surfaces.probe_z - new_probe_z +
                 surfaces.endstop_z - new_endstop_z)|round(6) %}
  {% if not params.IGNORE|default(0)|int %}
    {% for s in surfaces.available %}
      {% set offset = (surfaces.available[s].offset - diff)|round(6) %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : offset}) %}
    {% endfor %}
    { action_respond_info("All bed surfaces now adjusted by %1.4f"|
                          format(diff))}
  {% elif diff != 0 %}
    { action_respond_info("Status cleared without adjustment") }
  {% endif %}
  {% set dummy = surfaces.__setitem__('endstop_z', new_endstop_z| round(6)) %}
  {% set dummy = surfaces.__setitem__('probe_z', new_probe_z|round(6)) %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"

[gcode_macro set_surface_offset]
description: Sets the offset for a surface and moves the toolhead (if homed).
  Usage: SET_SURFACE_OFFSET [OFFSET=<offset>] [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE not in surfaces.available %}
    { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
  {% endif %}
  {% set active = surfaces.available[SURFACE] %}
  # If no offset is provided just print out the current offset.
  {% set OFFSET = params.OFFSET|default(active.offset)|float %}
  {% if OFFSET != active.offset %}
    {% set dummy = surfaces.available[SURFACE].__setitem__("offset", OFFSET) %}
    SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% if SURFACE == surfaces.active %}
      _km_set_gcode_offset_base Z="{OFFSET}" MOVE={
        1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
  {% endif %}
  { action_respond_info("Bed surface: %s Offset: %.3f"
                        | format(SURFACE, OFFSET)) }
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(active surface) %}
  {% set dummy = params.OFFSET|default(none)|float %}
  " %} # End argument block for Mainsail

[gcode_macro set_surface_active]
description: Sets the active bed surface and moves the toolhead (if homed). If
  no SURFACE argument is present the available surfaces are listed and the
  active one is preceded by a "*".
  Usage: SET_SURFACE_ACTIVE [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if "SURFACE" in params %}
    {% set SURFACE = params.SURFACE|lower %}
    {% if SURFACE not in surfaces.available %}
      { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
    {% endif %}
    {% if SURFACE != surfaces.active %}
      {% set dummy = surfaces.__setitem__("active", SURFACE) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
    {% if surfaces.available[SURFACE].offset !=
          printer.gcode_move.homing_origin.z %}
      _km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
        }" MOVE={1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
    {action_respond_info("Active bed surface: %s; offset: %.3f"
                        | format(SURFACE, surfaces.available[SURFACE].offset))}
  {% else %}
    {% set output = [] %}
    {% for s in surfaces.available|list|sort %}
      {% set dummy = output.append("%s&nbsp;%s - offset: %.3f" 
                      | format("*" if s == surfaces.active else "&nbsp;",
                                s, surfaces.available[s].offset)) %}
    {% endfor %}
    {action_respond_info(output|join('\n'))}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(none) %}
  " %} # End argument block for Mainsail

[gcode_macro set_gcode_offset]
description: Wraps SET_GCODE_OFFSET to update the current bed sheet offset.
  Usage: SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>]
                          [Y=<pos>|Y_ADJUST=<adjust>]
                          [Z=<pos>|Z_ADJUST=<adjust>]
                          [MOVE=1 [MOVE_SPEED=<speed>]]
rename_existing: _KM_SET_GCODE_OFFSET_BASE
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active and
        not printer["gcode_macro _km_save_state"].is_ephemeral %}
    {% set Z = params.Z|default(0.0)|float|round(6) %}
    {% set Z_ADJUST = params.Z_ADJUST|default(0.0)|float %}
    {% if 'Z' in params and
                 Z != surfaces.available[surfaces.active].offset %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__("offset",
                       Z) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% elif Z_ADJUST != 0.0 %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__(
        "offset", (Z_ADJUST + printer.gcode_move.homing_origin.z)|round(6)) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
  {% endif %}
  _km_set_gcode_offset_base{% for k in params%}{' '~k~'="'~params[k]~'"'
    }{% endfor %}

[gcode_macro make_surface_mesh]
description: Generates and saves a mesh to automatically load in PRINT_START.
  Usage: MAKE_SURFACE_MESH [SURFACE=<surface>] [BED=<probing temperature>]
                           [EXTRUDER=<probing temperature>]
                           [MESH_MULTIPLIER=<integer multiple of mesh density>]
                           [bed_mesh_calibrate parameters]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE not in surfaces.available %}
    { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
  {% endif %}
  {% set dummy = params.__setitem__('PROFILE', SURFACE) %}
  {% set BED = params.BED|default(70) | int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set EXTRUDER = params.EXTRUDER|default(km.start_extruder_probing_temp) |
                    int %}
  {% set MESH_MULTIPLIER = (params.MESH_MULTIPLIER|default(2)|int, 1)|max %}

  M104 S{EXTRUDER}
  M140 S{BED}
  G28

  # Adjust offset before running mesh
  {% if surfaces.available[SURFACE].offset !=
        printer.gcode_move.homing_origin.z %}
    _km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
      }" MOVE=1
  {% endif %}

  # If no offset is provided just print out the current offset.
  {% if BED > 0 %}
    {action_respond_info("Stabilizing bed at %iC" | format(BED,))}
    _KM_PARK_IF_NEEDED HEATER=heater_bed RANGE=0.5
    {% if BED < (printer.heater_bed.temperature - 0.2) %}
      M190 R{BED}
      G4 P{((km.start_bed_heat_delay * 10, 30000)|min,
            km.start_bed_heat_delay)|max}
    {% else %}
      G4 P{km.start_bed_heat_delay}
    {% endif %}
    M190 R{BED}
  {% endif %}

  {% if EXTRUDER > 0 %}
    _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
    M109 R{km.start_extruder_probing_temp}
  {% endif %}

  {% if km.start_home_z_at_temp and not bed_at_target %}
    G28 Z # Re-home only the Z axis now that the bed has stabilized.
  {% endif %}

  # Scale the mesh grid size while preserving the original points and relative
  # reference index.
  {% set probe_count = printer.configfile.settings.bed_mesh.probe_count
                         if not params.PROBE_COUNT else
                       params.PROBE_COUNT.split(",")|map('int')|list %}
  {% set dummy = params.__setitem__('PROBE_COUNT',(
                   MESH_MULTIPLIER * (probe_count[0] - 1) + 1,
                   MESH_MULTIPLIER * (probe_count[-1] - 1) + 1,)|join(',')) %}

  BED_MESH_CLEAR
  BED_MESH_CALIBRATE_FAST {%
    for k in params|reject('in',['BED','SURFACE'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %}
  SAVE_CONFIG

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.MESH_MULTIPLIER|default(2) %}
  {% set dummy = params.SURFACE|default(active surface) %}
  " %} # End argument block for Mainsail

[gcode_macro load_surface_mesh]
description: Attempts to load a mesh associated with the specified surface.
  Usage: LOAD_SURFACE_MESH [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE != surfaces.active %}
    SET_SURFACE_ACTIVE SURFACE={SURFACE}
  {% endif %}

  {% if SURFACE in printer.bed_mesh.profiles %}
    {% set mesh = printer.bed_mesh.profiles[SURFACE].mesh_params %}
    {% set default = printer.configfile.settings.bed_mesh %}
    # Ensure the saved mesh has at least the resolution of the default.
    {% if mesh.min_x <= (default.mesh_min[0] + 0.5) and
          mesh.min_y <= (default.mesh_min[1] + 0.5) and
          mesh.max_x >= (default.mesh_max[0] - 0.5) and
          mesh.max_y >= (default.mesh_max[1] - 0.5) and
          mesh.x_count >= default.probe_count[0] and
          mesh.y_count >= default.probe_count[-1] %}
      # Skip the bed level if we have a good profile.
      BED_MESH_PROFILE LOAD={SURFACE}
      {action_respond_info("Loaded mesh: %s" | format(SURFACE,))}
    {% endif %}
  {% endif %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro set_draw_params]
description: Sets the default parameters used by DRAW_LINE_TO.
  Usage: SET_DRAW_PARAMS [HEIGHT=<mm>] [WIDTH=<mm>] [FEEDRATE=<mm/m>]
variable_height: 0.2
variable_width: 0.0 # Set to nozzle_diameter at startup
variable_feedrate: 1200
gcode:
  {% set dparams = printer["gcode_macro set_draw_params"] %}
  {% for k in params %}
    {% set kl = k|lower %}
    {% if kl in dparams %}
      {% if dparams[kl] is float %}
        {% set v = params[k]|float %}
      {% elif dparams[kl] is integer %}
        {% set v = params[k]|int %}
      {% endif %}
      SET_GCODE_VARIABLE MACRO=set_draw_params VARIABLE={kl} VALUE="{v}"
    {% endif %}
  {% endfor %}

[gcode_macro draw_line_to]
description: Extrudes a line of filament at the specified height and width from
  the current coordinate to the supplied XY coordinate. (The height is used only
  to calculate the extrusion volume.)
  Usage: DRAW_LINE_TO [X=<pos>] [Y=<pos>] [HEIGHT=<mm>] [WIDTH=<mm>]
                      [FEEDRATE=<mm/m>]
gcode:
  {% set dparams = printer["gcode_macro set_draw_params"] %}
  {% set position = printer.gcode_move.gcode_position %}
  {% set X = params.X|default(position.x)|float %}
  {% set Y = params.Y|default(position.y)|float %}
  {% set HEIGHT = params.HEIGHT|default(dparams.height)|float %}
  {% set WIDTH = params.WIDTH|default(dparams.width)|float %}
  {% set FEEDRATE = params.FEEDRATE|default(dparams.feedrate)|int %}

  {% set distance = ((X - position.x) ** 2 + (Y - position.y) ** 2) ** 0.5 %}

  {% set filament_area = 3.14159 *
       (printer.configfile.settings[
          printer.toolhead.extruder].filament_diameter ** 2) / 4 %}
  {% set E = distance * ((WIDTH * HEIGHT) / filament_area) %}

  # Use the base state call here so offset adjustments get persisted.
  _KM_SAVE_GCODE_STATE NAME=_KM_PURGE
  G90
  G92 E0.0
  G1 X{"%.3f" % X} Y{"%.3f" % Y} E{"%.5f" % E} F{FEEDRATE}
  _KM_RESTORE_GCODE_STATE NAME=_KM_PURGE MOVE=0

[gcode_macro draw_purge_line]
description: Purges the specified length of filament as a line (or rows of
  lines) in front of the supplied print area. If no print area is specified the
  purge lines are drawn at the front edge of the maximum printable area. If no
  printable area is set it defaults to the XY axis limits.
  Usage: DRAW_PURGE_LINE [PRINT_MIN=<X,Y>] [PRINT_MAX=<X,Y>] [HEIGHT=<mm>]
                         [WIDTH=<mm>] [LENGTH=<mm>]
gcode:
  # TODO: Make this work for delta printers.
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set origin = printer.gcode_move.homing_origin %}
  {% set dummy = km.__setitem__('print_min', (km.print_min[0] - origin.x,
                                              km.print_min[1] - origin.y)) %}
  {% set dummy = km.__setitem__('print_max', (km.print_max[0] - origin.x,
                                              km.print_max[1] - origin.y)) %}

  {% if "PRINT_MIN" in params %}
    {% set PRINT_MIN = (
        (params.PRINT_MIN.split(",")[0]|float, km.print_min[0])|max,
        (params.PRINT_MIN.split(",")[1]|float, km.print_min[1])|max
      ) %}
  {% else %}
    {% set PRINT_MIN = km.print_min %}
  {% endif %}
  {% if "PRINT_MAX" in params %}
    {% set PRINT_MAX = (
        (params.PRINT_MAX.split(",")[0]|float, km.print_max[0])|min,
        (params.PRINT_MAX.split(",")[1]|float, km.print_max[1])|min
      ) %}
  {% else %}
    {% set PRINT_MAX = km.print_max %}
  {% endif %}
  {% set extruder = printer.toolhead.extruder|string %}
  {% set HEIGHT = params.HEIGHT|default(
    printer.configfile.settings[extruder].nozzle_diameter * 0.625)|float %}
  {% set WIDTH = params.WIDTH|default(
    printer.configfile.settings[extruder].nozzle_diameter * 1.25)|float %}
  {% set LENGTH = params.LENGTH|default(km.start_purge_length)|float %}

  {% set dparams = printer["gcode_macro set_draw_params"] %}
  {% set filament_area = 3.14159 *
       (printer.configfile.settings[extruder].filament_diameter ** 2) / 4 %}
  {% set purge_length = (LENGTH * filament_area) / (WIDTH * HEIGHT) %}
  {% set printable_length = PRINT_MAX[0] - PRINT_MIN[0] %}
  {% set purge_rows = (purge_length / printable_length)|round(0,'ceil')|int %}
  {% set printable_inset = (printable_length - purge_length / purge_rows) / 2 %}
  {% set PRINT_MIN = (PRINT_MIN[0] + printable_inset, PRINT_MIN[1]) %}
  {% set PRINT_MAX = (PRINT_MAX[0] - printable_inset, PRINT_MAX[1]) %}
  # This will purge into the print area when the bed is filled to the front.
  {% set y_start = (km.print_min[1], PRINT_MIN[1] - km.start_purge_clearance -
                                       (purge_rows + 0.5) * WIDTH )|max %}
  G90
  # Jog to the front left corner to get strings out of the print area.
  G1 X{"%.3f" % (PRINT_MIN[0] - 30, km.print_min[0])|max} Y{
    "%.3f" % (y_start - 10, km.print_min[1])|max} F{km.travel_speed_xy}
  # Move to the starting corner.
  G1 X{"%.3f" % (PRINT_MIN[0] - km.start_purge_prime_length / WIDTH,
                 km.print_min[0])|max} Y{"%.3f" % y_start} Z{
    "%.4f" % HEIGHT} F{km.travel_speed_xy}
  # Prime the extruder before beginning the purge lines.
  G92 E0.0
  # Move slowly during priming to prevent excessive blobbing
  G1 X{"%.3f" % PRINT_MIN[0]} E{"%.3f" % km.start_purge_prime_length
   } F{km.load_priming_speed}
  G92 E0.0
  # Purge.
  {% for n in range(purge_rows - 1) %}
    {% set x_pos = PRINT_MIN[0] if n % 2 else PRINT_MAX[0] %}
    DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
      WIDTH * n + y_start}"
    DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
      WIDTH * (n + 1) + y_start}"
  {% endfor %}
  {% set x_pos = PRINT_MAX[0] if purge_rows % 2 else PRINT_MIN[0] %}
  DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
    WIDTH * (purge_rows - 1) + y_start}"
  G92 E0.0

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _check_fan_params]
gcode:
  {% set MAXIMUM = params.MAXIMUM|default(
      printer["gcode_macro set_fan_scaling"].maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(
      printer["gcode_macro set_fan_scaling"].minimum)|int %}

  {% if params.SCALE and params.SCALE|float <= 0 %}
    { action_raise_error("SCALE must be a positive value.") }
  {% elif MINIMUM < 0 or MINIMUM > 255 %}
    { action_raise_error("MINIMUM must be between 0 and 255.") }
  {% elif MAXIMUM < 0 or MAXIMUM > 255 %}
    { action_raise_error("MAXIMUM must be between 0 and 255.") }
  {% elif params.SPEED and (params.SPEED|int < 0 or params.SPEED|int > 255) %}
    { action_raise_error("SPEED must be between 0 and 255.") }
  {% elif params.BOOST and (params.BOOST|int < 0 or params.BOOST|int > 255) %}
    { action_raise_error("BOOST must be between 0 and 255.") }
  {% elif MINIMUM > MAXIMUM %}
    { action_raise_error("MINIMUM must be less than or equal to MAXIMUM.") }
  {% endif %}

# Sets optional scaling factor, minimum, and maximum applied to M106 commmand.
# If a MINIMUM greater than 0 is specified the fan will not stop unless an
# M107 command is issued. SET_FAN_SCALING always displays the current paramaters
# if scaling is active. SET_FAN_SCALING without any arguments will display the
# current scaling parameters without changing them.
[gcode_macro set_fan_scaling]
description: Sets fan scaling factors applied to M106 command. If a speed is
  provided it will be adjusted according to the scaling parameters.
  Usage: SET_FAN_SCALING [SCALE=<scale>] [BOOST=<boost>] [MAXIMUM=<max>]
                         [MINIMUM=<min>] [SPEED=<speed>]
variable_scale: 1.0
variable_boost: 0
variable_minimum: 0
variable_maximum: 255
variable_real_speed: 0
gcode:
  _CHECK_FAN_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
  {% set SCALE = params.SCALE|default(scale)|float %}
  {% set BOOST = params.BOOST|default(boost)|float %}
  {% set MAXIMUM = params.MAXIMUM|default(maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(minimum)|int %}
  {% set SPEED = params.SPEED|default(real_speed)|int %}

  {% if SCALE != 1.0 or BOOST != 0 or MAXIMUM != 255 or MINIMUM != 0 %}
    {action_respond_info("Fan: Scale: %.2f Minimum:%i Maximum: %i Speed: %i"|
                         format(SCALE, MINIMUM, MAXIMUM, SPEED))}
  {% endif %}

  # Update parameters on change.
  {% if params|length > 0 %}
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=scale VALUE="{SCALE}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=boost VALUE="{BOOST}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=minimum VALUE="{MINIMUM}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=maximum VALUE="{MAXIMUM}"
    # Run fan at adusted speed
    M106 S{SPEED}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0)|int %}
  {% set dummy = params.MAXIMUM|default(255)|int %}
  {% set dummy = params.MINIMUM|default(0)|int %}
  {% set dummy = params.SPEED|default(current speed)|int %}
  " %} # End argument block for Mainsail

[gcode_macro reset_fan_scaling]
description: Clears all fan scaling factors.
  Usage: RESET_FAN_SCALING
gcode:
  SET_FAN_SCALING SCALE=1.0 BOOST=0 MAXIMUM=255 MINIMUM=0

[gcode_macro m106]
description: Wraps M106 to implement scaling overrides.
rename_existing: M106.6245197
gcode:
  {% set S = params.S|default(255)|int %}
  {% set scale = printer["gcode_macro set_fan_scaling"] %}
  SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=real_speed VALUE="{S}"
  M106.6245197 S{((((S + scale.boost) * scale.scale) | round | int,
                   scale.minimum) | max, scale.maximum) | min}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _load_unload]
gcode:
  {% set saved_extruder = printer.toolhead.extruder %}
  {% set EXTRUDER = params.EXTRUDER|default(saved_extruder)|lower %}
  {% set km = printer["gcode_macro _km_globals"] %}
  # Use the global min as default if provided, else use per extruder min + 5.
  {% set default_minimum = km.load_min_temp if km.load_min_temp else
         (printer.configfile.settings[EXTRUDER].min_extrude_temp + 5) %}
  {% if 'MINIMUM' in params %}
    {% set MINIMUM = params.MINIMUM|int %}
  # This is the special case for a filament change after an idle timeout.
  {% elif printer.pause_resume.is_paused and printer[EXTRUDER].target == 0 and
          printer["gcode_macro resume"].saved_extruder_temp %}
    {% set MINIMUM = printer["gcode_macro resume"].saved_extruder_temp %}
  # Use the target temp if higher than the default.
  {% elif printer[EXTRUDER].target > default_minimum %}
    {% set MINIMUM = printer[EXTRUDER].target %}
  {% else %}
    {% set MINIMUM = default_minimum %}
  {% endif %}
  {% if MINIMUM < printer.configfile.settings[EXTRUDER].min_extrude_temp %}
    { action_raise_error("Extrude below minimum temp.") }
  {% elif printer.pause_resume.is_paused %}
    # Clear the saved E if we're (un-)loading while paused.
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
  {% endif %}
  {% set SPEED = params.SPEED|default(km.load_speed)|int %}
  {% set priming_length = km.load_priming_length %}
  {% set LENGTH = params.LENGTH|default(km.load_length)|float - priming_length%}
  {% if LENGTH < 0 %}
    {% set priming_length = (priming_length + LENGTH, 0)|max %}
    {% set LENGTH = 0 %}
  {% endif %}
  SAVE_GCODE_STATE NAME=_KM_LOAD_UNLOAD
  {% if EXTRUDER != saved_extruder%}
    ACTIVATE_EXTRUDER EXTRUDER={EXTRUDER}
  {% endif %}
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  {% if not printer.extruder.can_extrude or
        printer[EXTRUDER].target < default_minimum %}
    {action_respond_info("Preheating %s to %d" | format(EXTRUDER, MINIMUM))}
    M109 S{MINIMUM}
  {% endif %}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS={"filament_load"
    if params.LOAD|int else "filament_unload"}
  M83
  {% set priming_speed = (km.load_priming_speed, SPEED)|min %}
  {% if params.LOAD|int %}
    G0 E{LENGTH} F{SPEED}
    G0 E{priming_length} F{priming_speed}
    G0 E{'%.4f' % -printer["gcode_macro resume"].saved_e} F{km.load_speed}
  {% else %}
    {% set pre_prime_distance = 5.0 %}
    {% set shaping_moves = 5 %}
    {% set shaping_distance = (shaping_moves * (1 + shaping_moves)/20) %}
    # Push forward to heat up, then retract to the edge of the meltzone.
    G0 E{pre_prime_distance} F{SPEED}
    G4 P500
    G0 E{'%.4f' % -(priming_length - shaping_distance)} F{SPEED}
    # Shape the tip with a pairs of short extrusions and retractions, where
    # the retractions get increasingly longer than the extrusion.
    {% for i in range(1, shaping_moves + 1) %}
      G0 E2 F{priming_speed}
      G0 E-{2 + (0.1 * i)} F{priming_speed}
    {% endfor %}
    # Retract the rest of the length.
    G0 E{'%.4f' % -(LENGTH + pre_prime_distance)} F{SPEED}
  {% endif %}
  RESTORE_GCODE_STATE NAME=_KM_LOAD_UNLOAD

  # Beep on completion
  _KM_BEEP_IF_AVAILABLE BEEPS={params.BEEPS|default(8)}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

# TODO: Fix casing after front-ends get fixed
[gcode_macro LOAD_FILAMENT]
description: Loads filament to the extruder.
  Usage: LOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
                       [EXTRUDER=<extruder>] [MINIMUM=<temperature>]
                       [BEEPS=<beep count on completion>]
gcode:
  _LOAD_UNLOAD LOAD=1{% for k in params
    %}{' '~k~'="'~params[k]~'"'}{% endfor %}

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  M109
  {% set dummy = params.LENGTH|default(variable_load_length)|float %}
  {% set dummy = params.SPEED|default(variable_load_speed)|float %}
  {% set dummy = params.EXTRUDER|default(current extruder) %}
  {% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
  {% set dummy = params.BEEPS|default(10)|int %}
  " %} # End argument block for Mainsail

# TODO: Fix casing after front-ends get fixed
[gcode_macro UNLOAD_FILAMENT]
description: Unloads filament from the extruder.
  Usage: UNLOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
                         [EXTRUDER=<extruder>] [MINIMUM=<temperature>]
                         [BEEPS=<beep count on completion>]
gcode:
  _LOAD_UNLOAD LOAD=0{% for k in params
    %}{' '~k~'="'~params[k]~'"'}{% endfor %}

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  M109
  {% set dummy = params.LENGTH|default(variable_load_length)|float %}
  {% set dummy = params.SPEED|default(variable_load_speed)|float %}
  {% set dummy = params.EXTRUDER|default(default extruder) %}
  {% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
  {% set dummy = params.BEEPS|default(10)|int %}
  " %} # End argument block for Mainsail

[gcode_macro _pause_inner_m700]
gcode:
  {% set extruder = "extruder" ~ params.T|replace('0', '')
     if "T" in params else printer.toolhead.extruder %}
  {% if extruder != printer.toolhead.extruder%}
    ACTIVATE_EXTRUDER EXTRUDER={extruder}
  {% endif %}

  {% set z_param = (' Z="%f"' % params.Z) if 'Z' in params else "" %}

  {% if printer.idle_timeout.state|string == "Printing" %}
    PAUSE B="{0}" P=2{z_param}
  {% elif not printer.pause_resume.is_paused%}
    PARK B="{0}" P=2{z_param}
  {% endif %}

[gcode_macro m701]
description: Pauses/parks the toolhead then loads filament to the extruder.
  Usage: M701 [L<distance>] [Z<pos>] [T<extruder>]
gcode:
  {% if 'U' in params %}
    {% if not 'L' in params %}
      RESPOND TYPE=error MSG="Argument \"U\" substituted for missing \"L\"."
      {% set dummy = params.__setitem__("L", params.U) %}
    {% else %}
      RESPOND TYPE=error MSG="Invalid argument \"U\" ignored."
    {% endif %}
  {% endif %}

  _PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  LOAD_FILAMENT BEEPS="{10}" LENGTH={
    params.L|default(printer["gcode_macro _km_globals"].load_length)|float}

[gcode_macro m702]
description: Pauses/parks the toolhead then unloads filament from the extruder.
  Usage: M702 [U<distance>] [Z<pos>] [T<extruder>]
gcode:
  {% if 'L' in params %}
    {% if not 'U' in params %}
      RESPOND TYPE=error MSG="Argument \"L\" substituted for missing \"U\"."
      {% set dummy = params.__setitem__("U", params.L) %}
    {% else %}
      RESPOND TYPE=error MSG="Invalid argument \"L\" ignored."
    {% endif %}
  {% endif %}

  _PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  UNLOAD_FILAMENT BEEPS="{10}" LENGTH={
    params.U|default(printer["gcode_macro _km_globals"].load_length)|float}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

################################################################################
#
# Declare any of the below variables in your own [gcode_macro _km_options] to
# to override the values here.
#
# DO NOT CHANGE ANYTHING IN THIS FILE!!!
#
# This file handles the initialization for all the macros, and difficult to
# diagnose errors will result from unexpected values or code changes.
#
################################################################################
[gcode_macro _km_globals]
# Available bed surfaces for offset adjustments.
variable_bed_surface_max_name_length: 10
# Available bed surfaces for offset adjustments.
variable_bed_surfaces: ['default']
# Total length (in mm) of filament to load (bowden tubes will be much longer).
variable_load_length: 90.0
# Global minimum extruder temp for loading (default: min_extrude_temp + 5).
variable_load_min_temp: 0
# Length (in mm) of the extruder meltzone (feeds at priming speed).
variable_load_priming_length: 20.0
# Filament priming speed (in mm/m).
variable_load_priming_speed: 200
# Filament loading speed (in mm/m).
variable_load_speed: 1200
# Set to False to hide the Octoprint LCD menus.
variable_menu_show_octoprint: True
# Set to False to hide the SD Card LCD menus.
variable_menu_show_sdcard: True
# List up to 10 pre-heat settings in order for the LCD "Temperature" menu
variable_menu_temperature: [
  {'name' : 'PLA',  'extruder' : 200, 'bed' : 60},
  {'name' : 'PETG', 'extruder' : 230, 'bed' : 85},
  {'name' : 'ABS',  'extruder' : 245, 'bed' : 110}]
# X position to park toolhead (set "max" or "min" to infer from stepper config).
variable_park_x: 0.0
# Y position to park toolhead (set "max" or "min" to infer from stepper config).
variable_park_y: 0.0
# Z position to park toolhead (set "max" or "min" to infer from stepper config).
variable_park_z: 20.0
# Minimum printable XY coordinate. Defaults to X and Y position_min.
variable_print_min: () # example: (0, 0)
# Maximum printable XY coordinate. Defaults to X and Y position_max.
variable_print_max: () # example: (220, 220)
# Scaling factor for M900 command (negative values make M900 a no-op).
variable_pressure_advance_scale: -1.0
# Additional padding around the specified print area for a bed mesh.
variable_probe_mesh_padding : 5.0
# Minimum number of probes per axis for partial probing of a bed mesh.
variable_probe_min_count: 3
# Scaling factor to increase probe count for partial bed probes.
variable_probe_count_scale: 1.0
# Additional delay (in ms) during bed heating, to allow the bed to stabilize.
variable_start_bed_heat_delay: 2000
# Amount (in degrees C) to overshoot bed target temp before stabilizing.
variable_start_bed_heat_overshoot: 2.0
# Set to clear adjustments (e.g. feedrate, extrusion, heater) at end of print.
variable_start_clear_adjustments_at_end: True
# PRINT_END Y park position (set "max" or "min" to infer from stepper config).
variable_start_end_park_y: 0.0 # Defaults to print_max Y.
# Extruder scale factor during pre-warmup in PRINT_START.
variable_start_extruder_preheat_scale: 0.5
# If non-zero the extruder will stabilize at this temp before probing the bed.
variable_start_extruder_probing_temp: 0
# Set to rehome Z in PRINT_START after bed temp stabilizes; False to disable.
variable_start_home_z_at_temp: True
# Set to level bed in PRINT_START after bed temp stabilizes; False to disable.
variable_start_level_bed_at_temp: True
# Distance (in millimeters) between the purge lines and the print area.
variable_start_purge_clearance: 2.0
# Length of filament (in millimeters) to purge at print start.
variable_start_purge_length: 0.0 # 30 is a good starting point.
# Length of filament (in millimeters) to prime before drawing purge lines.
variable_start_purge_prime_length: 12.0
# Level gantry in PRINT_START after bed temp stabilizes; False to disable.
variable_start_quad_gantry_level_at_temp: True
# Maximum distance to relocate print in random XY location to reduce bed wear.
variable_start_random_placement_max: 0
# The relocation will be at least this far from the printable edge of the bed.
variable_start_random_placement_padding: 10.0
# Skip level and load saved mesh for current sheet (if found); False to disable.
variable_start_try_saved_surface_mesh: False
# Adjust Z tilt in PRINT_START after bed temp stabilizes; False to disable.
variable_start_z_tilt_adjust_at_temp: True
# X and Y travel speed (in mm/m) for movement macros.
variable_travel_speed_xy: 3000
# Z travel speed in (mm/m) for movement macros.
variable_travel_speed_z: 600
################################################################################
description: Initializes our globals, including any _km_options overrides.
gcode:
  # Doing a shutdown here is a bit aggressive, but if we're missing required
  # sections then a lot of things could go very bad later.
  # To minimize the annoyance we try to identify all the fatal errors at once.
  # format is:
  #   key = required config section
  #   value[0] = required field in section
  #   value[1] = required string in field
  #   A "None" value means there's no required field
  {% set required_sections = {"heater_bed" : None,
                              "extruder" : None,
                              "gcode_macro _km_options" : None,
                              "idle_timeout" : ("gcode", "_KM_IDLE_TIMEOUT"),
                              "pause_resume" : None,
                              "respond" : None,
                              "save_variables" : None,
                              "virtual_sdcard" :
                                ("on_error_gcode", "CANCEL_PRINT")
                             } %}
  {% set warn_removed = {
    "start_extruder_set_target_before_level" :
      "The start_extruder_set_target_before_level option has been removed. "
      "Use the start_extruder_probing_temp option instead to set a fixed "
      "probing temperature.",
    "start_gcode_before_print" :
      "The start_gcode_before_print option has been removed. The same effect "
      "can now be achieved by inserting custom gcode before the "
      "_PRINT_START_PHASE_PURGE line in your slicer's start gcode, or by "
      "wrapping the _PRINT_START_PHASE_PURGE macro. See the Slicer "
      "Configuration section in the readme for more information.",
    "velocity_decel_scale" :
      "The velocity_decel_scale option has been removed. Klipper's input "
      "shaping provides a superior mechanism for improving print quality "
      "at higher speeds.",
  } %}
  {% set output = [] %}
  {% for s in required_sections %}
    {% set f = required_sections[s][0] if required_sections[s] else None %}
    {% set v = required_sections[s][1] if required_sections[s] else None %}
    {% if s not in printer.configfile.config %}
      {% set dummy = output.append("Missing [%s] section.\n" | format(s)) %}
    {% elif f and
            (v not in printer.configfile.config[s][f]|default("")|upper) %}
      {% set dummy = output.append("Missing %s in %s for [%s] section.\n"
                                   | format(v, f, s)) %}
    {% endif %}
  {% endfor %}
  {% if output %}
    { action_emergency_stop((
        "required printer.cfg section(s) missing:\n"
        ~ output | join("\n")) ~
        "See readme: https://github.com/jschuh/klipper-macros\x23klipper-setup")
    }
  {% endif %}

  # These are all set to their defaults based on config options:
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_level_bed_at_temp VALUE="{
    1 if printer.bed_mesh is defined else 0}"
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_quad_gantry_level_at_temp VALUE="{
    1 if printer.quad_gantry_level is defined else 0}"
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_z_tilt_adjust_at_temp VALUE="{
    1 if printer.z_tilt is defined else 0}"
  {% set toolhead = printer.toolhead %}
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=print_min VALUE="{
    (toolhead.axis_minimum.x, toolhead.axis_minimum.y)}"
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=print_max VALUE="{
    (toolhead.axis_maximum.x, toolhead.axis_maximum.y)}"
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_end_park_y VALUE="{
    toolhead.axis_maximum.y}"
  {% set settings = printer.configfile.settings %}
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_home_z_at_temp VALUE="{
    1 if ("stepper_z" in settings and
          settings.stepper_z.endstop_pin.split()|join("")|lower ==
            "probe:z_virtual_endstop") else 0}"

  {% set options = printer["gcode_macro _km_options"] %}
  {% set km = printer["gcode_macro _km_globals"] %}

  # Allow placeholders for parking positions.
  {% if options.park_x|default("")|string|lower == "min" %}
    {% set dummy = options.__setitem__("park_x",
                      printer.configfile.settings.stepper_x.position_min) %}
  {% elif options.park_x|default("")|string|lower == "max" %}
    {% set dummy = options.__setitem__("park_x",
                      printer.configfile.settings.stepper_x.position_max) %}
  {% endif %}
  {% if options.park_y|default("")|string|lower == "min" %}
    {% set dummy = options.__setitem__("park_y",
                      printer.configfile.settings.stepper_y.position_min) %}
  {% elif options.park_y|default("")|string|lower == "max" %}
    {% set dummy = options.__setitem__("park_y",
                      printer.configfile.settings.stepper_y.position_max) %}
  {% endif %}
  {% if options.start_end_park_y|default("")|string|lower == "min" %}
    {% set dummy = options.__setitem__("start_end_park_y",
                      printer.configfile.settings.stepper_y.position_min) %}
  {% elif options.start_end_park_y|default("")|string|lower == "max" %}
    {% set dummy = options.__setitem__("start_end_park_y",
                      printer.configfile.settings.stepper_y.position_max) %}
  {% endif %}
  {% if options.park_z|default("")|string|lower == "min" %}
    {% set dummy = options.__setitem__("park_z",
                      printer.configfile.settings.stepper_z.position_min) %}
  {% elif options.park_z|default("")|string|lower == "max" %}
    {% set dummy = options.__setitem__("park_z",
                      printer.configfile.settings.stepper_z.position_max) %}
  {% endif %}

  # Force overrides to use the original types in _KM_GLOBALS.
  {% for k in options %}
    {% if k not in km %}
      {% if k in warn_removed %}
        {action_respond_info(warn_removed[k])}
      {% else %}
        {% set dummy = output.append("%s is not valid for _KM_OPTIONS." |
                         format(k)) %}
      {% endif %}
    {% elif km[k] is string %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="'{options[k]|replace('\\','\\\\')|replace('\'','\\\'')
                             |replace('\"','\\\"')}'"
    {% elif km[k] is float %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|float}"
    {% elif km[k] is integer or km[k] is boolean %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k} VALUE="{options[k]|int}"
    {% elif km[k] is mapping %}
      {% if options[k] is not mapping %}
        {% set dummy = output.append("%s requires a mapping type." |
                         format(k)) %}
      {% endif %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|replace('\"','\\\"')}"
    {% elif km[k] is sequence %}
      {% if options[k] is not sequence %}
        {% set dummy = output.append("%s requires a sequence type." |
                         format(k)) %}
      {% endif %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|replace('\"','\\\"')}"
    {% else %}
      {% set dummy = output.append("%s is not a valid type for _KM_OPTIONS." |
                        format(k)) %}
    {% endif %}
  {% endfor %}

  {% if "homing_override" in printer.configfile.config %}
    {% for l in printer.configfile.config.homing_override.gcode.split("\n") %}
        {% if " g28 " in (" " ~ l.split("\x23")[0].split(";")[0]|lower ~ " ") %}
          {% set dummy = output.append(
              "G28 in [homing_override] gcode. Replace with G28.6245197 to "
              "fix recursive macro call.\n"
              "See readme: https://github.com/jschuh/klipper-macros\x23g28") %}
        {% endif %}
    {% endfor %}
  {% endif %}
  SET_GCODE_VARIABLE MACRO=check_km_config VARIABLE=load_errors VALUE="{
    output|replace('\"','\\\"')}"
  M400

[delayed_gcode INIT_GLOBALS]
# This runs once at startup and initializes all macros.
initial_duration: 1
gcode:
  LIST_MACROS SILENT=1 # Build the macro cache.
  _KM_GLOBALS
  # This needs to be its own macro so it gets evaluated after _KM_GLOBALS runs.
  CHECK_KM_CONFIG
  _INIT_SURFACES
  BED_MESH_CHECK
  # Sets the default drawing parameters.
  SET_DRAW_PARAMS WIDTH="{printer.configfile.settings.extruder.nozzle_diameter}"
  # This is any end-user gcode that need to run after macro initialization.
  _KM_OPTIONS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=ready

[gcode_macro check_km_config]
variable_load_errors: []
description: Checks global variables and throws an error on any invalid values.
  Does nothing if the config has no errors.
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set toolhead = printer.toolhead %}
  {% set output = load_errors %}
  {% if km.park_x > toolhead.axis_maximum.x or
        km.park_x < toolhead.axis_minimum.x %}
    {% set dummy = output.append("park_x is invalid.") %}
  {% endif %}
  {% if km.park_y > toolhead.axis_maximum.y or
        km.park_y < toolhead.axis_minimum.y %}
    {% set dummy = output.append("park_y is invalid.") %}
  {% endif %}
  {% if km.park_z > toolhead.axis_maximum.z or
        km.park_z < toolhead.axis_minimum.z %}
    {% set dummy = output.append("park_z is invalid.") %}
  {% endif %}
  {% if km.print_max[0] > toolhead.axis_maximum.x or
        km.print_max[1] > toolhead.axis_maximum.y %}
    {% set dummy = output.append("print_max is invalid.") %}
  {% endif %}
  {% if km.print_min[0] < toolhead.axis_minimum.x or
        km.print_min[1] < toolhead.axis_minimum.y %}
    {% set dummy = output.append("print_min is invalid.") %}
  {% endif %}
  {% if km.start_extruder_preheat_scale > 1.0 or
        km.start_extruder_preheat_scale < 0.0 %}
    {% set dummy = output.append("extruder_preheat_scale is invalid.") %}
  {% endif %}
  {% if km.load_length > 
        printer.configfile.settings["extruder"].max_extrude_only_distance %}
    {% set dummy = output.append(
      "load_length exceeds max_extrude_only_distance.") %}
  {% endif %}
  {% if km.load_length < km.load_priming_length %}
    {% set dummy = output.append(
      "load_length is shorter than load_priming_length.") %}
  {% endif %}
  {% if km.load_length < 0.0 %}
    {% set dummy = output.append("load_length is negative.") %}
  {% endif %}
  {% if km.load_priming_length < 0.0 %}
    {% set dummy = output.append("load_priming_length is negative.") %}
  {% endif %}

  # Emit all the config errors.
  {% if output %}
    { action_raise_error(output|sort|join('\nError: ')) }
  {% endif %}
  M400

[gcode_macro kmvars]
description: Lists global variables used by klipper-macros.
  Usage: KMVARS [SEARCH=<search_string>]
gcode:
  {% set SEARCH = params.SEARCH|default(params.S|default(""))|lower %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set output = [] %}
  {% for k in km %}
    {% if SEARCH in k %}
      {% set dummy = output.append(k ~ ": " ~ km[k]) %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output|sort|join('\n')) }

[gcode_macro check_macro_docs]
description: Lists macros lacking proper documentation.
  Usage: CHECK_MACRO_DOCS [USAGE=<0|1>] [HIDDEN=<1|0>] [RENAMED=<1|0>]
gcode:
  {% set USAGE = params.USAGE|default(0)|int %}
  {% set HIDDEN = params.HIDDEN|default(0)|int %}
  {% set RENAMED = params.RENAMED|default(0)|int %}
  {% set output = [] %}
  {%set config = printer.configfile.config %}
  {% for k in config|sort %}
    {% if k.startswith("gcode_macro") %}
      {% set name = k.split()[1] %}
      {% set desc = config[k].description|default("") %}
      {% set is_renamed = config[k].rename_existing|default("") %}
      {% if (not desc or (USAGE and not "Usage: "~name.upper() in desc)) and
             (HIDDEN or not name.startswith('_')) and (RENAMED or is_renamed) %}
        {% set dummy = output.append("%s&nbsp;%s: missing %s."
           | format("*" if is_renamed else "&nbsp;", name,
                    "description" if not desc else "usage")) %}
      {% endif %}
    {% endif %}
  {% endfor %}
  {action_respond_info(output|join("\n"))}

# The below macro is a lightly edited version of the one found here:
# https://klipper.discourse.group/t/example-search-printer-objects/164
[gcode_macro listvars]
description: Lists per-macro variables with a name containing SEARCH. This is 
  useful for debugging macros by allowing you to probe printer state. Be very
  careful, however, as an overly broad SEARCH parameter can take a long time
  to process and potentially hang or crash klipper.
  Usage: LISTVARS SEARCH=<search_string>
gcode:

  {% if 'SEARCH' not in params and 'S' not in params %}
    { action_raise_error("Must provide a SEARCH parameter.") }
  {% endif %}
  {% set SEARCH = params.SEARCH|default(params.S)|lower %}
  {% set ns = namespace() %}
  {% set output = [] %}
  {% for item in printer %}
    {% if item is not string %}
      {% set ns.path = ['printer', "[%s]" % (item|string), ''] %}
    {% elif ' ' in item %}
      {% set ns.path = ['printer', "['%s']" % (item), ''] %}
    {% else %}
      {% set ns.path = ['printer.', item, ''] %}
    {% endif %}

    {% if SEARCH in ns.path|lower %}
      {% set dummy = output.append(ns.path|join) %}
    {% endif %}

    {% if printer[item].items() %}
      {% for childkey, child in printer[item].items() recursive %}
          {% set ns.path = ns.path[:loop.depth|int + 1] %}
          {% if childkey is not string %}
            {% set null = ns.path.append("[%s]" % (childkey|string)) %}
          {% elif ' ' in childkey %}
            {% set null = ns.path.append("['%s']" % (childkey)) %}
          {% else %}
            {% set null = ns.path.append(".%s" % (childkey)) %}
          {% endif %}

          {% if child is mapping  %}
            {loop(child.items())}
          {% else %}
            {% if SEARCH in ns.path|lower %}
              {% set dummy = output.append("%s : %s" % (ns.path|join, child)) %}
            {% endif %}
          {% endif %}
        {% endfor %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output|join("\n")) }

[gcode_macro list_macros]
description: Lists registered macros (and optionally show variable state).
  Usage: LISTVARS SEARCH=<search_string> VARS=<0|1> SILENT=<0|1>
variable_macros: {}
gcode:
  # Load the config state once and save it.
  {% if not macros %}
    {% set renames = {} %}
    {% for k in printer.configfile.config %}
      {% if k.lower().startswith("gcode_macro") and
            printer.configfile.config[k].rename_existing %}
          {% set name = k.split(None, 1)[1] | lower %}
          {% set dummy = renames.__setitem__(name,
                          [printer.configfile.config[k].rename_existing|lower] +
                            renames[name]|default([])) %}
      {% endif %}
    {% endfor %}
    {% for k in printer %}
      {% if k.lower().startswith("gcode_macro") %}
        {% set name = k.split(None, 1)[1] | lower %}
        {% set dummy = macros.__setitem__(name, renames[name]|default([])) %}
      {% endif %}
    {% endfor %}
  {% endif %}

  {% if params.SILENT|default(0)|int == 0 %}
    _LIST_MACROS_DISPLAY {rawparams}
  {% endif %}

[gcode_macro _list_macros_display]
gcode:
  {% set SEARCH = params.SEARCH | default(params.S) | default("") | lower %}
  {% set VARS = params.VARS | default(params.V) | default(0) | int != 0 %}

  {% set macros = printer["gcode_macro list_macros"].macros %}
  {% set output = [] %}
  {% for k in macros %}
    {% if SEARCH in k | lower %}
      {% set line = k ~ ((" (renames: %s)" % (macros[k]|join(","))) if macros[k]
                          else "") %}
      {% set outvars = [] %}
      {% if VARS %}
        {% for v in printer["gcode_macro " ~ k] | sort %}
          {% set dummy = outvars.append("\n* %s: %s" %
                           (v, printer["gcode_macro " ~ k][v]|string)) %}
        {% endfor %}
      {% endif %}
      {% set dummy = output.append(line + outvars | join("")) %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output | sort | join("\n")) }

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro set_heater_temperature_scaled]
gcode:
  {% set HEATER = params.HEATER.lower() %}
  {% set TARGET = params.TARGET|default(0.0)|float %}
  {% set scaled_heaters =
           printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if HEATER in scaled_heaters %}
    {% set scales = scaled_heaters[HEATER] %}
    {% set dummy = scales.__setitem__("real_target", TARGET) %}
    {%if TARGET > 0.0 %}
      {% set TARGET = (((TARGET + scales.bump) * scales.scale, scales.minimum)
                       | max, scales.maximum)|min %}
    {% endif %}
  {% endif %}
  SET_HEATER_TEMPERATURE HEATER="{HEATER}" TARGET={TARGET}

[gcode_macro temperature_wait_scaled]
gcode:
  {% set SENSOR = params.SENSOR.lower() %}
  {% set heater = SENSOR if not SENSOR.startswith("heater_generic") else
                  SENSOR.split()[1] %}
  {% set scaled_heaters =
           printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if heater in scaled_heaters %}
    {% set scales = scaled_heaters[heater] %}
    {% if "MINIMUM" in params and MINIMUM > 0.0 %}
      {% set MINIMUM = (((MINIMUM + scales.bump) * scales.scale, scales.minimum)
                        | max, scales.maximum)|min %}
    {% endif %}
    {% if "MAXIMUM" in params and MAXIMUM > 0.0 %}
      {% set MAXIMUM = (((MAXIMUM + scales.bump) * scales.scale, scales.minimum)
                        | max, scales.maximum)|min %}
    {% endif %}
  {% else %}
    {% set settings = printer.configfile.settings[SENSOR] %}
    {% set MINIMUM = params.MINIMUM|default(settings.min_temp) %}
    {% set MAXIMUM = params.MAXIMUM|default(settings.max_temp) %}
  {% endif %}
  {% if printer[sensor].temperature < MINIMUM or
        printer[sensor].temperature > MAXIMUM %}
    TEMPERATURE_WAIT SENSOR="{SENSOR}" MINIMUM={MINIMUM} MAXIMUM={MAXIMUM}
  {% endif %}

[gcode_macro _gcode_wait_wrapper_inner]
gcode:
  # Macro variables are evaluated at instantiation, so this inner macro is what
  # gets us a scaled target value.
  {% set sensor = params.HEATER if params.HEATER in
       printer.heaters.available_heaters 
     else ("heater_generic " ~ params.HEATER) %}
  {% set target = printer[sensor].target %}
  {% if 'R' in params and target > 0.0 %}
    {% set T = params.T|default("") %}
    M{params.M}.6245197 S{target} { (" T"~T) if T else "" }
  {% elif printer[sensor].temperature < target %}
    TEMPERATURE_WAIT SENSOR="{sensor}" MINIMUM={target}
  {% endif %}

[gcode_macro _gcode_wait_wrapper]
gcode:
  {% set target = params.S | default(params.R | default(0))| float %}
  SET_HEATER_TEMPERATURE_SCALED HEATER="{params.HEATER}" TARGET={target}
  _GCODE_WAIT_WRAPPER_INNER{%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m109]
rename_existing: M109.6245197
gcode:
  {% set extruder = "extruder" ~ params.T|replace('0', '')
     if "T" in params else printer.toolhead.extruder %}
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating
  _GCODE_WAIT_WRAPPER HEATER={extruder}{%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m190]
rename_existing: M190.6245197
gcode:
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=bed_heating
  _GCODE_WAIT_WRAPPER HEATER=heater_bed {%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m191]
description: Sets chamber temperature (with wait for heating).
  Usage: M191 [S<temp>]
gcode:
  # Just fake the R parameter for the chamber.
  {% if "R" in params %}
    {% set dummy = params.__setitem__("S", params.R) %}
  {% endif %}
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=chamber_heating
  _GCODE_WAIT_WRAPPER HEATER=chamber {%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m104]
rename_existing: M104.6245197
gcode:
  {% set extruder = "extruder" ~ params.T|replace('0', '')
     if "T" in params else printer.toolhead.extruder %}
  SET_HEATER_TEMPERATURE_SCALED HEATER={extruder} TARGET={params.S|default(0)}

[gcode_macro m140]
rename_existing: M140.6245197
gcode:
  SET_HEATER_TEMPERATURE_SCALED HEATER=heater_bed TARGET={params.S|default(0)}

[gcode_macro m141]
description: Sets chamber temperature.
  Usage: M141 [S<temp>]
gcode:
  SET_HEATER_TEMPERATURE_SCALED HEATER=chamber TARGET={params.S|default(0)}

[gcode_macro _check_heater_params]
gcode:
  {% set HEATER = params.HEATER|lower %}
  {% set sensor = params.HEATER %}
  {% if HEATER not in printer.heaters.available_heaters %}
    {% set sensor = "heater_generic " ~ HEATER %}
    {% if sensor not in printer.heaters.available_heaters %}
      { action_raise_error("The value '%s' is not valid for HEATER"
                            | format(HEATER)) }
    {% endif %}
  {% endif %}
  {% set settings = printer.configfile.settings[sensor] %}
  {% set scaled_heaters =
       printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if HEATER is in scaled_heaters %}
    {% set scales = scaled_heaters[HEATER] %}
  {% else %}
    {% set scales = { "scale": 1.0, "bump": 0.0, "minimum": settings.min_temp,
                      "maximum": settings.max_temp,
                      "real_target": printer[sensor].target} %}
  {% endif %}
  {% set SCALE = params.SCALE|default(scales.scale)|float %}
  {% set BUMP = params.BUMP|default(scales.bump)|float %}
  {% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
  {% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}

  {% if SCALE <= 0 %}
    { action_raise_error("SCALE must be a positive value.") }
  {% elif MINIMUM < settings.min_temp or MINIMUM > settings.max_temp %}
    { action_raise_error("MINIMUM must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% elif MAXIMUM < settings.min_temp or MAXIMUM > settings.max_temp %}
    { action_raise_error("MAXIMUM must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% elif MINIMUM >= MAXIMUM %}
    { action_raise_error("MINIMUM must be less than MAXIMUM.") }
  {% elif "TARGET" in params and (params.TARGET|float < MINIMUM or
                                  params.TARGET|float > MAXIMUM) %}
    { action_raise_error("TARGET must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% endif %}

[gcode_macro set_heater_scaling]
description: Sets scaling parameters for heater. If a new target temperature is
  passed it will be adjusted to the scaling parameters.
  Usage: SET_HEATER_SCALING [HEATER=<heater>] [SCALE=<scale_factor>]
                            [BUMP=<degrees>] [MAXIMUM=<degrees>]
                            [MINIMUM=<degrees>] [TARGET=<temp>]
variable_scaled_heaters: {}
gcode:
  # If no heater is supplied just list out all the scaled heaters.
  {% if "HEATER" is not in params %}
    {% set output = [] %}
    {% for h in scaled_heaters %}
      {% set dummy = output.append(
         "%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f"
         | format(h, scaled_heaters[h].scale, scaled_heaters[h].bump,
                  scaled_heaters[h].minimum, scaled_heaters[h].maximum)) %}
    {% endfor %}
    {% if output %}}{action_respond_info(output|join('\n'))}{% endif %}
  {% else %}
    # See if we need a new scaling entry for this heater.
    {% set HEATER = params.HEATER.lower() %}
    {% set settings = printer.configfile.settings[HEATER] %}
    {% if HEATER is not in scaled_heaters %}
      {% set dummy = scaled_heaters.__setitem__(HEATER, {"scale": 1.0,
         "bump": 0.0, "minimum": settings.min_temp,
         "maximum": settings.max_temp,
         "real_target": printer[HEATER].target}) %}
    {% endif %}
    _CHECK_HEATER_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
    {% set scales = scaled_heaters[HEATER] %}
    {% set SCALE = params.SCALE|default(scales.scale)|float %}
    {% set BUMP = params.BUMP|default(scales.bump)|float %}
    {% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}
    {% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
    {% set TARGET = params.TARGET|default(scales.real_target)|float %}
    {% set dummy = scales.__setitem__("scale", SCALE) %}
    {% set dummy = scales.__setitem__("bump", BUMP) %}
    {% set dummy = scales.__setitem__("maximum", MAXIMUM) %}
    {% set dummy = scales.__setitem__("minimum", MINIMUM) %}
    {% set dummy = scales.__setitem__("real_target", TARGET) %}

    {% set settings = printer.configfile.settings[HEATER] %}
    {% if SCALE != 1.0 or BUMP != 0.0 or MINIMUM != settings.min_temp or
          MAXIMUM != settings.max_temp %}
      {% set dummy = scaled_heaters.__setitem__(HEATER, scales) %}
    {% else %} # Remove a redundant scaling entry.
      {% set dummy = scaled_heaters.__delitem__(HEATER) %}
    {% endif %}
    SET_HEATER_TEMPERATURE_SCALED HEATER={HEATER} TARGET={TARGET}
    {action_respond_info(
       "%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f Target: %.1f"
       | format(HEATER, SCALE, BUMP, MINIMUM, MAXIMUM, TARGET))}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.HEATER|default(e.g. extruder) %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0.0)|float %}
  {% set dummy = params.MAXIMUM|default(max_temp)|float %}
  {% set dummy = params.MINIMUM|default(min_temp)|float %}
  {% set dummy = params.TARGET|default(current target)|float %}
  " %} # End argument block for Mainsail

[gcode_macro reset_heater_scaling]
description: Clears scaling for heater (or all heaters if none specified).
  Usage: RESET_HEATER_SCALING [HEATER=<heater>]
gcode:
  {% if "HEATER" in params %}
    {% set HEATER = params.HEATER.lower() %}
    {% if HEATER not in printer.heaters.available_heaters %}
      { action_raise_error("The value '%s' is not valid for HEATER"
                           | format(HEATER)) }
    {% endif %}
    {% set settings = printer.configfile.settings[HEATER] %}
    SET_HEATER_SCALING HEATER={HEATER
                     } SCALE=1.0 BUMP=0.0 MINIMUM={settings.min_temp
                     } MAXIMUM={settings.max_temp}
  {% else %}
    # Clear everything if no heater was provided.
    SET_GCODE_VARIABLE MACRO=set_heater_scaling VARIABLE=scaled_heaters VALUE={
      "{}"}
  {% endif %}

[gcode_macro _km_idle_timeout]
gcode:
  {% if printer.pause_resume.is_paused %}
    {action_respond_info("Extruder powered down on idle timeout.")}
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{
      printer[printer.toolhead.extruder].target}"
    M104; Turn off extruder but leave the bed on.
  {% else %}
    TURN_OFF_HEATERS
    M107; turn off fan
    M84
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=ready
  {% endif %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _check_kinematic_limits]
gcode:
  {% set toolhead = printer.toolhead %}
  {% if params.X and (params.X|float < toolhead.axis_minimum.x or
                      params.X|float > toolhead.axis_maximum.x) %}
    {action_raise_error("X[%.3f] must be between %.3f and %.3f."
                        | format(params.X|float, toolhead.axis_minimum.x,
                                 toolhead.axis_maximum.x))}
  {% elif params.Y and (params.Y|float < toolhead.axis_minimum.y or
                        params.Y|float > toolhead.axis_maximum.y) %}
    {action_raise_error("Y[%.3f] must be between %.3f and %.3f."
                        | format(params.Y|float, toolhead.axis_minimum.y,
                                 toolhead.axis_maximum.y))}
  {% elif params.Z and (params.Z|float < toolhead.axis_minimum.z or
                        params.Z|float > toolhead.axis_maximum.z) %}
    {action_raise_error("Z[%.3f] must be between %.3f and %.3f."
                        | format(params.Z|float, toolhead.axis_minimum.z,
                                 toolhead.axis_maximum.z))}
  {% elif params.E and (params.E|float|abs > printer.configfile.settings[
                          "extruder"].max_extrude_only_distance) %}
    {action_raise_error("E[%.4f] exceeds max_extrude_only_distance[%.4f]."
       | format(params.E|float|abs, printer.configfile.settings[
                                      "extruder"].max_extrude_only_distance))}
  {% endif %}

[gcode_macro lazy_home]
description: Homes the specified axes. If lazy is true, already homed axes
  are skipped.
  Usage: LAZY_HOME [LAZY=<1|0>] [AXES=<axes_string>]
gcode:
  # This is split apart so we can force the macro rename cache to be ready.
  LIST_MACROS SILENT=1
  _LAZY_HOME_INNER {rawparams}

[gcode_macro _lazy_home_inner]
gcode:
  # Find the real g28 command.
  {% set G28 = (printer["gcode_macro list_macros"].macros.g28|
                  default(["g28"],True))[-1] %}
  {% set axes = 'XYZ'|select('in', params.AXES|default("XYZ")|upper|list) %}
  {% if not axes %} # No axes means home everything.
    {% set axes = 'XYZ' %}
  {% endif %}
  {% if params.LAZY|default(1)|int %} # Prune out the already homed axes.
    {% set axes = axes|reject('in', printer.toolhead.homed_axes|upper)|join() %}
  {% endif %}

  {% if axes %}
    _KM_PRINT_STATUS ACTION=PUSH_STATUS
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=homing
    {G28}{% for k in axes %}{' ' ~ k}{% endfor %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status
  {% endif %}

[gcode_macro g28]
description: Wraps the G28 command to add the Marlin "O" parameter so that
  already homed axes will not be homed again. See the Klipper documentation on
  G28 for the behavior of the other parameters.
  Usage: G28 [O] ...
rename_existing: G28.6245197
gcode:
  {% set axes = 'XYZ'|select('in', params)|join() %}
  LAZY_HOME LAZY={('O' in params)|int}{%if axes%} AXES={axes}{%endif%}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro before_layer_change]
description: Add this to the "before layer change" input box in the slicer.
  Usage: BEFORE_LAYER_CHANGE HEIGHT=<current_height> LAYER=<current_layer>
gcode:
  {% set height = params.HEIGHT|default(printer.toolhead.position.z)|float %}
  {% set layer = params.LAYER|default(-1)|int + 1 %}
  {% if height >= 0.0 and layer >= 0 %}
    SET_PRINT_STATS_INFO CURRENT_LAYER="{layer}"
    SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{height}"
    {% if printer["gcode_macro _km_layer_run"].clearance_z < height %}
      SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{
        height}"
    {% endif %}
  {% endif %}

[gcode_macro after_layer_change]
description: Add this to the "after layer change" input box in the slicer.
  Usage: AFTER_LAYER_CHANGE
gcode:
  _KM_LAYER_RUN

[gcode_macro gcode_at_layer]
description: Schedules the specified g-code command to be run at the specified
  layer. LAYER=next will cause the command to run at the next layer change. 
  Usage: GCODE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } COMMAND=<gcode> 
                        [CANCEL=<0|1>]
gcode:
  {% set tot_layers = printer.print_stats.info.total_layer %}
  {% if params|length > 0 %}
    _KM_CHECK_IS_PRINTING

    {% set CANCEL = params.CANCEL|default(0)|int != 0 %}
    {% set COMMAND = params.COMMAND|default(None) %}
    {% if COMMAND %} # This makes it easier to match commands for cancellation.
      {% set COMMAND = COMMAND.lstrip().split(None, 1) %}
      {% set COMMAND = " ".join([COMMAND[0]|upper] + COMMAND[1:]) %}
    {% endif %}

    {% if "LAYER" in params %}
      {% set cmd_container = "commands_layer" %}
      {% set cur_layer = printer.print_stats.info.current_layer|int %}
      {% if "HEIGHT" in params %}
        {action_raise_error("Conflicting HEIGHT and LAYER arguments provided.")}
      {% elif params.LAYER|string|lower == "next" %}
        {% set LAYER = cur_layer + 1 %}
      {% else %}
        {% set LAYER = params.LAYER|int %}
      {% endif %}
      {% if LAYER <= cur_layer %}
        {action_raise_error("LAYER[%i] must be above current print layer[%i]."
                            | format(LAYER, cur_layer))}
      {% elif tot_layers and LAYER > tot_layers %}
        {action_raise_error("LAYER[%i] must not be above top layer[%i]."
                            | format(LAYER, tot_layers))}
      {% endif %}
      {% set key = LAYER %}

    {% elif "HEIGHT" in params %}
      {% set cmd_container = "commands_height" %}
      {% set HEIGHT = params.HEIGHT|float %}
      {% set cur_height = printer["gcode_macro _km_layer_run"].cur_height %}
      {% if HEIGHT <= cur_height %}
        {action_raise_error(
          "HEIGHT[%.3f] must be above current print height[%.3f].")
          | format(HEIGHT, cur_height)}
      {% elif HEIGHT >= printer.toolhead.axis_maximum.z %}
        {action_raise_error(
          "HEIGHT[%.3f] must be below maximum Z height[%.3f].")
          | format(HEIGHT, printer.toolhead.axis_maximum.z)}
      {% endif %}
      {% set key = HEIGHT %}

    {% else %}
      {action_raise_error("No HEIGHT or LAYER argument provided.")}
    {% endif %}
  
    {% set commands = printer["gcode_macro _km_layer_run"][cmd_container] %}
    {% if key not in commands and not CANCEL %}
      {% set dummy = commands.__setitem__(key, []) %}
    {% endif %}

    {% if CANCEL %}
      {% if key in commands %}
        {% set pos = ("%i"|format(key)) if key is integer else
                      ("%.3fmm"|format(key)) %}
        {% if COMMAND %}
          {% set dummy = commands[key].remove(COMMAND) %}
          {% if commands[key]|length == 0 %}
            {% set dummy = commands.__delitem__(key) %}
          {% endif %}
          {action_respond_info("Cancelled %s %s:\n* %s" |
                               format("layer" if k is integer else "height",
                                      pos, COMMAND))}
        {% else %}
          {% set dummy = commands.__delitem__(key) %}
          {action_respond_info("Cancelled all commands at %s %s." |
                               format("layer" if k is integer else "height",
                                      pos))}
        {% endif %}
      {% endif %}
    {% elif not COMMAND %}
      {action_raise_error("No COMMAND argument provided.")}
    {% elif COMMAND in commands[key] %}
      {action_raise_error("Duplicate command previously scheduled.")}
    {% else %}
      {% set dummy = commands[key].append(COMMAND) %}
      {% set pos = ("%i"|format(key)) if key is integer else
                   ("%.3fmm"|format(key)) %}
      {action_respond_info("%s %s:\n* %s" |
                           format("layer" if key is integer else "height",
                                  pos, COMMAND))}
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE={cmd_container} VALUE="{
        commands|replace('\"','\\\"')}"
    _UPDATE_LAYER_COMPAT

  # No arguments means just list all the triggers.
  {% else %}
    {% set output = [] %}
    {% set commands = printer["gcode_macro _km_layer_run"].commands_layer %}
    {% for key in commands|list|sort %}
      {% set dummy = output.append("layer %i:" | format(key)) %}
      {% for c in commands[key] %}
        {% set dummy = output.append("* %s" | format(c)) %}
      {% endfor %}
    {% endfor %}
    {% set commands = printer["gcode_macro _km_layer_run"].commands_height %}
    {% for key in commands|list|sort %}
      {% set dummy = output.append("height %.3fmm:" | format(key)) %}
      {% for c in commands[key] %}
        {% set dummy = output.append("* %s" | format(c)) %}
      {% endfor %}
    {% endfor %}
    {action_respond_info(output|join('\n'))}
  {% endif %}

[gcode_macro _km_layer_run]
description: Runs pending commands for the current layer change.
  Usage: _KM_LAYER_RUN
variable_cur_height: 0.0
variable_clearance_z: 0.0
variable_commands_layer: {}
variable_commands_height: {}
gcode:
  {% set cur_layer = printer.print_stats.info.current_layer %}
  {% for key in commands_layer | select("<=", cur_layer) | sort %}
    {action_respond_info("Executing scheduled commands at layer %d:\n%s" |
        format(key, commands_layer[key]|join('\n')))}
    {% for c in commands_layer[key] %}
      {c}
    {% endfor %}
    {% set dummy = commands_layer.__delitem__(key) %}
  {% endfor %}
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{
      commands_layer|replace('\"','\\\"')}"
  {% for key in commands_height | select("<=", cur_height) | sort %}
    {action_respond_info("Executing scheduled commands at height %.3f:\n%s" |
        format(key, commands_height[key]|join('\n')))}
    {% for c in commands_height[key] %}
      {c}
    {% endfor %}
    {% set dummy = commands_height.__delitem__(key) %}
  {% endfor %}
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{
      commands_height|replace('\"','\\\"')}"
  _UPDATE_LAYER_COMPAT

[gcode_macro init_layer_gcode]
description: Clears scheduled gcode commands and state for all layers.
  Usage: INIT_LAYER_GCODE LAYERS=<num>
gcode:
  SET_PRINT_STATS_INFO TOTAL_LAYER="{params.LAYERS|int + 1}" CURRENT_LAYER="{0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
  _UPDATE_LAYER_COMPAT

[gcode_macro _reset_layer_gcode]
description: Clears scheduled gcode commands and state for all layers.
  Usage: _RESET_LAYER_GCODE
gcode:
  SET_PRINT_STATS_INFO TOTAL_LAYER="{0}" CURRENT_LAYER="{0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
  _UPDATE_LAYER_COMPAT

[gcode_macro cancel_all_layer_gcode]
description: Clears all scheduled gcode commands.
  Usage: CANCEL_ALL_LAYER_GCODE
gcode:
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
  _UPDATE_LAYER_COMPAT

#
# Begin Mainsail/Fluidd compat
#

[gcode_macro SET_PAUSE_NEXT_LAYER]
description: Enable a pause if the next layer is reached
gcode:
  _KM_CHECK_IS_PRINTING
  {% set pause_next_layer =
           printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
  {% set ENABLE = params.ENABLE | default(1) | int != 0 %}
  {% set MACRO = params.MACRO | default(pause_next_layer.call, True) %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VALUE="{
    { 'enable': False, 'call': MACRO }}" VARIABLE=pause_next_layer
  GCODE_AT_LAYER COMMAND="{MACRO|replace('\"','\\\"')
              }" CANCEL="{0 if ENABLE else 1}" LAYER="next"

[gcode_macro SET_PAUSE_AT_LAYER]
description: Enable/disable a pause if a given layer number is reached
gcode:
  _KM_CHECK_IS_PRINTING
  {% set pause_at_layer =
           printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
  # This enable logic is copied directly from Fluidd/Mainsail.
  {% set ENABLE = params.ENABLE | int != 0 if params.ENABLE is defined else
                  params.LAYER is defined %}
  {% set LAYER = params.LAYER |
                 default((pause_at_layer.layer|int,
                          printer.print_stats.info.current_layer|int + 1)|max)%}
  {% set MACRO = params.MACRO | default(pause_at_layer.call, True) %}

  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{
    { 'enable': False, 'layer': 0, 'call': MACRO }}"
  {% if ENABLE and pause_at_layer.enable %}
    # Remove the previously scheduled command if we're replacing it.
    GCODE_AT_LAYER COMMAND="{pause_at_layer.call|replace('\"','\\\"')
                }" CANCEL="{1}" LAYER="{pause_at_layer.layer}"
  {% endif %}
  # Add the new command.
  GCODE_AT_LAYER COMMAND="{MACRO|replace('\"','\\\"')
              }" CANCEL="{0 if ENABLE else 1}" LAYER="{LAYER}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing: _KM_SET_PRINT_STATS_INFO
description: Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer: { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer  : { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode:
  _KM_SET_PRINT_STATS_INFO {rawparams}

[gcode_macro _update_layer_compat]
gcode:
  {% set next_layer = printer.print_stats.info.current_layer|int + 1 %}
  {% set commands_layer = printer["gcode_macro _km_layer_run"].commands_layer %}
  {% set keys = commands_layer | sort(reverse=True) %}

  {% set pause_next_layer = {'enable': False, 'call':
           printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer.call} %}
  {% if pause_next_layer.call in commands_layer[next_layer] | default([]) %}
    {% set dummy = pause_next_layer.__setitem__('enable', True) %}
  {% endif %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{
    pause_next_layer|replace('\"','\\\"') }"

  # Don't just make pause_at_layer a copy of pause_next_layer.
  {% set pause_at_layer = {'enable': False, 'layer': 0, 'call':
           printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer.call} %}
  {% if pause_next_layer.enable and
          pause_next_layer.call == pause_at_layer.call %}
    {% set keys = keys | reject("==", next_layer) %}
  {% endif %}

  # We iterate through the entire reverse sorted key list because Jinja2 doesn't
  # have a filter for dict values. It's ugly, but there should be only a few
  # items in the dict.
  {% for key in keys %}
    {% if pause_at_layer.call in commands_layer[key] %}
      {% set dummy = pause_at_layer.__setitem__('enable', True) %}
      {% set dummy = pause_at_layer.__setitem__('layer', key) %}
    {% endif %}
  {% endfor %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{
    pause_at_layer|replace('\"','\\\"') }"

#
# End Mainsail/Fluidd compat
#

[gcode_macro pause_next_layer]
description: Convenience macro to schedule the current print to pause at the
  next layer change. See PAUSE for additional arguments.
  Usage: PAUSE_NEXT_LAYER ...
gcode:
  _CHECK_KINEMATIC_LIMITS{% for k in params%}{' ' ~k~ '=' ~ params[k]
    }{% endfor %}
  GCODE_AT_LAYER LAYER=NEXT COMMAND="PAUSE{% for k in params %}{
    ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro pause_at_layer]
description: Convenience macro to schedule the current print to pause at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. See PAUSE for additional arguments.
  Usage: PAUSE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  _CHECK_KINEMATIC_LIMITS{% for k in filtered_params%}{' ' ~k~ '=' ~ params[k]
   }{% endfor %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="PAUSE{% for k in filtered_params %}{
      ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro speed_at_layer]
description: Convenience macro to schedule a feedrate adjustment at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. (SPEED parameter behaves the same as the M220 S parameter.)
  Usage: SPEED_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } SPEED=<percentage>
gcode:
  {% set SPEED = params.SPEED|default(0)|int %}
  {% if SPEED < 1 or SPEED > 500 %}
    {action_raise_error("SPEED[%i] parameter between 1 and 500 is required."
                        % SPEED)}
  {% endif %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M220 S{SPEED|int}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.SPEED|default(percentage)|int %}
  " %} # End argument block for Mainsail

[gcode_macro flow_at_layer]
description: Convenience macro to schedule a flow percentage adjustment at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. (FLOW parameter behaves the same as the M221 S parameter.)
  Usage: FLOW_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } FLOW=<percentage>
gcode:
  {% set FLOW = params.FLOW|default(0)|int %}
  {% if FLOW < 1 or FLOW > 500 %}
    {action_raise_error("FLOW[%i] parameter between 1 and 500 is required."
                        % FLOW)}
  {% endif %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M221 S{FLOW|int}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.FLOW|default(percentage)|int %}
  " %} # End argument block for Mainsail

[gcode_macro fan_at_layer]
description: Convenience macro to schedule a fan adjustment at the specified
  layer change. LAYER=next will cause the command to run at the next layer
  change. See SET_FAN_SCALING for additional arguments.
  Usage: FAN_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0)|int %}
  {% set dummy = params.MAXIMUM|default(0)|int %}
  {% set dummy = params.MINIMUM|default(255)|int %}
  {% set dummy = params.SPEED|default(current speed)|int %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  {% if filtered_params|length == 0 %}
    {action_raise_error("No fan parameters provided.")}
  {% endif %}
  _CHECK_FAN_PARAMS{% for k in filtered_params %}{' '~k~'='~params[k]
    }{% endfor %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="SET_FAN_SCALING{% for k in filtered_params %}{
      ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro heater_at_layer]
description: Convenience macro to schedule a heater adjustment at the specified
  layer change. LAYER=next will cause the command to run at the next layer
  change. See SET_HEATER_SCALING for additional arguments.
  Usage: HEATER_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.HEATER|default(e.g. extruder) %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0.0)|float %}
  {% set dummy = params.MAXIMUM|default(max_temp)|float %}
  {% set dummy = params.MINIMUM|default(min_temp)|float %}
  {% set dummy = params.TARGET|default(current target)|float %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  _CHECK_HEATER_PARAMS{% for k in filtered_params%}{' ' ~ k ~ '=' ~ params[k]
    }{% endfor %}
  GCODE_AT_LAYER{% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="SET_HEATER_SCALING{% for k in filtered_params %}{
      ' ' ~ k ~ '=\\\"' ~ params[k]|replace('\\','\\\\')|replace('\'','\\\'')
                                   |replace('\"','\\\"') ~ '\\\"'
    }{% endfor %}"

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro park]
description: Park the toolhead
  Usage: PARK [P=<0|1|2>] [X=<pos>] [Y=<pos>] [Z=<pos>] [LAZY=<1|0>]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set LAZY = params.LAZY|default(1)|int %}
  {% if printer.toolhead.homed_axes != "xyz" %}
    {% if LAZY %}
      LAZY_HOME
    {% else %}
      {action_raise_error("Must home axes first.")}
    {% endif %}
  {% endif %}

  # Z position type from G27 (if below, absolute, relative)
  {% set P = (params.P|default(2))|int %} # Default to 2 because it's sanest.
  {% set X = params.X|default(km.park_x)|float %}
  {% set Y = params.Y|default(km.park_y)|float %}
  {% set Z = params.Z|default(km.park_z)|float %}

  M400
  _CHECK_KINEMATIC_LIMITS X="{X}" Y="{Y}" Z="{Z}"
  _PARK_INNER X="{X}" Y="{Y}" Z="{Z}" P="{P}" LAZY="{LAZY}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.P|default(mode=<0|1|2>)|int %}
  {% set dummy = params.X|default(X position)|int %}
  {% set dummy = params.Y|default(Y position)|int %}
  {% set dummy = params.Z|default(Z position)|int %}
  " %} # End argument block for Mainsail

[gcode_macro _park_inner]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set travel_speed_xy = km.travel_speed_xy %}
  {% set travel_speed_z = km.travel_speed_z %}

  {% set position = printer.gcode_move.gcode_position %}
  {% set origin = printer.gcode_move.homing_origin%}

  # Use the taller of the highest printed layer or the current Z height, which
  # should help avoid crashes (e.g. when a sequential print in progress).
  {% set clearance_z = (printer["gcode_macro _km_layer_run"].clearance_z,
                        position.z) | max %}
  {% set P = params.P|int %}
  {% set X = params.X|float - origin.x %}
  {% set Y = params.Y|float - origin.y %}
  {% set Z = params.Z|float %}
  {% set LAZY = params.LAZY|int %}

  # Convert everything to absolute coordinates.
  {% if P == 0 %} # Move absolute to Z if below current Z
    {% if clearance_z > Z %}
      {% set Z = clearance_z %}
    {% endif %}
  {% elif P == 1 %} # Move Z absolute.
      {% set Z = Z - origin.z %}
  {% elif P == 2 %} # Move Z relative
    {% set Z = Z + clearance_z %}
  {% else %}
    {action_raise_error("Invalid parameter P=%i. Value must be 0, 1, or 2." |
        format(P)) }
  {% endif %}

  # Clamp to the printer limits.
  {% set Z = ((Z, printer.toolhead.axis_maximum.z - origin.z)|min,
              printer.toolhead.axis_minimum.z - origin.z)|max %}

  # Don't move if it's a lazy park and we're already in position.
  {% if (not LAZY) or P != 2 or X != position.x or Y != position.y 
        or Z < clearance_z %}
    SAVE_GCODE_STATE NAME=_KM_PARK
    G90
    G0 Z{Z} F{travel_speed_z}
    G0 X{X} Y{Y} F{travel_speed_xy}
    RESTORE_GCODE_STATE NAME=_KM_PARK MOVE=0
  {% endif %}


[gcode_macro g27]
description: Parks the toolhead.
  Usage: G27 [P=<0|1|2>]
gcode:
  # Wraps any arguments for the PARK macro and defaults P=0 for Marlin compat.
  PARK P={params.P|default(0)} {% for k in params|reject("in", "GP") %}{
    ' '~k~'="'~params[k]~'"'
    }{% endfor %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

# Enables pause/resume functionality
[gcode_macro pause]
description: Pauses the current print.
  Usage: PAUSE [X=<pos>] [Y=<pos>] [Z=<pos>] [E=<retract_length>] [B=<beeps>]
rename_existing: _KM_PAUSE_BASE
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  # Retract length (negative)
  {% set E = (params.E|default(5))|float %}

  {% if printer.pause_resume.is_paused %}
    { action_respond_info("Print already paused") }
  {% elif printer.idle_timeout.state | string == "Printing" or
          (printer.virtual_sdcard|default({})).is_active|default(False) %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=pausing RESET_STACK=1
    {% set position = printer.gcode_move.gcode_position %}
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_x VALUE="{position.x}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_y VALUE="{position.y}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_z VALUE="{position.z}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{E}"
    SAVE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE
    _KM_PAUSE_BASE
    M83
    {% if printer.extruder.can_extrude %}
      G1 E{'%.4f' % -E} F{km.load_speed}
    {% endif %}
    PARK P=2{% for k in params|select("in", "XYZ") %}{
        ' '~k~'="'~params[k]~'"'}{% endfor %}
    _KM_BEEP_IF_AVAILABLE BEEPS={params.B|default(10)}
  {% else %}
    { action_respond_info("Print not in progress") }
  {% endif %}

[gcode_macro m600]
description: Pauses the current print.
  Usage: M600 [B<beeps>] [E<pos>] [L<pos>] [R<temp>] [U<pos>] [X<pos>] [Y<pos>]
              [Z<pos>]
gcode:
  PAUSE B="{0}" P=2{% for k in params|select("in", "EXYZ") %}{
      ' '~k~'="'~params[k]~'"'}{% endfor %}
  UNLOAD_FILAMENT{% if 'U' in params %} LENGTH={params.U}{% endif
               %} BEEPS="{params.B|default(10)|int}"
  {% if 'R' in params %}M109 S{params.R}{% endif %}

[gcode_macro m601]
description: Pauses the current print.
  Usage: M601
gcode:
  PAUSE

[gcode_macro m602]
description: Resumes the currently paused print.
  Usage: M602
gcode:
  RESUME

[gcode_macro m24]
rename_existing: M24.6245197
gcode:
  {% if printer.pause_resume.is_paused %}
  RESUME
  {% else %}
  M24.6245197
  {% endif %}

[gcode_macro m25]
rename_existing: M25.6245197
gcode:
  PAUSE

[gcode_macro resume]
description: Resumes the currently paused print.
  Usage: RESUME [E<pos>]
rename_existing: _KM_RESUME_BASE
variable_saved_extruder_temp: 0
variable_saved_x: 0.0
variable_saved_y: 0.0
variable_saved_z: 0.0
variable_saved_e: 0.0
gcode:
  {% if printer.pause_resume.is_paused %}
    {% set km = printer["gcode_macro _km_globals"] %}
    # Warm the extruder back up if needed.
    {% set extruder = printer[printer.toolhead.extruder] %}
    {% if extruder.target <= printer.configfile.settings[
                               printer.toolhead.extruder].min_temp
                             | float + 0.5 %}
      M109 S{saved_extruder_temp}
    {% endif %}

    # If there's no saved_e assume we're completing a filament change and
    # retract enough to avoid drooling on the model.
    {% if 'E' not in params and not saved_e %}
      {% set saved_e = 5.0 %}
      G1 E{'%.4f' % -saved_e } F{km.load_speed}
    {% endif %}

    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
    G90
    # Move back to last position before unretracting.
    G0 X{saved_x} Y{saved_y} F{km.travel_speed_xy}
    G0 Z{saved_z} F{km.travel_speed_z}
    G91
    # Unretract
    G1 E{'%.4f' % (params.E|default(saved_e))} F{km.load_speed}
    RESTORE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE MOVE=1
    _KM_RESUME_BASE
  {% else %}
    { action_respond_info("Printer is not paused.") }
  {% endif %}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=printing RESET_STACK=1

# TODO: Fix casing after front-ends get fixed
[gcode_macro CANCEL_PRINT]
description: Cancels the current print.
  Usage: CANCEL_PRINT
rename_existing: _KM_CANCEL_PRINT_BASE
gcode:
  _KM_CHECK_IS_PRINTING
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=cancelling RESET_STACK=1
  SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{True}"
  PRINT_END
  _KM_CANCEL_PRINT_BASE
  {% if printer.pause_resume.is_paused %}
    RESTORE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE MOVE=0
  {% endif %}
  CLEAR_PAUSE
  _KM_APPLY_PRINT_OFFSET RESET=1
  {% if 'virtual_sdcard' in printer and not printer.virtual_sdcard.is_active %}
    SDCARD_RESET_FILE
  {% endif %}

[gcode_macro clear_pause]
description: Clears the current pause state.
  Usage: CLEAR_PAUSE
rename_existing: _KM_CLEAR_PAUSE
gcode:
  SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
  _KM_CLEAR_PAUSE

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro print_start]
description: Inserted by slicer at start of print. Rather than using this macro
  directly you should configure your slicer as instructed in the readme.
  Usage: PRINT_START BED=<temp> EXTRUDER=<temp> [CHAMBER=<temp>]
                     [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [LAYERS=<num>]
                     [NOZZLE_SIZE=<mm>]
gcode:
  {action_respond_info(
    "This file is using an old The PRINT_START format. This print will run "
    "fine, but you should update your slicer config to take advantage of the "
    "phased PRINT_START macros. The slicer documentation is here:\n"
    "https://github.com/jschuh/klipper-macros\x23slicer-configuration"
  )}

  _PRINT_START_PHASE_INIT {rawparams}
  _PRINT_START_PHASE_PREHEAT
  _PRINT_START_PHASE_PROBING
  _PRINT_START_PHASE_EXTRUDER
  _PRINT_START_PHASE_PURGE

[gcode_macro _print_start_phase_init]
description: Inserted by slicer at start of print. Initializes PRINT_START
  phases.
  Usage: See PRINT_START.
gcode:
  CHECK_KM_CONFIG # Need this in case startup errors were missed.
  SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
  _KM_APPLY_PRINT_OFFSET RESET=1
  _PRINT_START_PHASE_CHECK PHASE=none
  {% set km = printer["gcode_macro _km_globals"] %}

  {% if not params.BED %}
    {% set dummy = params.__setitem__('BED', params.BED_TEMP|int) %}
  {% endif %}
  {% if not params.EXTRUDER %}
    {% set dummy = params.__setitem__('EXTRUDER', params.EXTRUDER_TEMP|int) %}
  {% endif %}

  # Stash all the params for use by the other phases.
  PRINT_START_SET PRINT_START_PHASE="init" {% for k in params %}{' %s=\"%s\"' %
    (k,params[k]|replace('\\','\\\\')|replace('\'','\\\'')|replace('\"','\\\"'))
  }{% endfor %}

  # Check and propogate the printable bounds.'
  _km_check_and_set_print_bounds

  M107 # Turn off part cooling fan in case it was on.
  CLEAR_PAUSE
  # Kick off the longest preheats in the init.
  M140 S{params.BED}
  {% if params.CHAMBER %}M141 S{params.CHAMBER|int}{% endif %}
  {% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
  # Load a saved mesh if configured.
  {% if km.start_try_saved_surface_mesh and printer.bed_mesh %}
    LOAD_SURFACE_MESH
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="preheat"

[gcode_macro _print_start_phase_preheat]
description: Inserted by slicer at start of print. Handles the bed and chamber
  heating phases and ends when both are stabilized at their target temperatures.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=preheat
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set BED = print.BED|int %}
  {% set EXTRUDER = print.EXTRUDER|int %}
  {% set CHAMBER = print.CHAMBER|default(0)|int %}
  {% set LAYERS = print.LAYERS|default(0)|int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  # The bed started at no more than 0.2C below and 1.0C above the target temp.
  {% set bed_at_target = (BED + 0.4 - printer.heater_bed.temperature) |
                           abs <= 0.6 %}
  PRINT_START_SET BED_AT_TARGET={1 if bed_at_target else 0}
  {% set start_level_bed_at_temp = km.start_level_bed_at_temp and
                                   not printer.bed_mesh.profile_name %}
  {% set actions_at_temp = start_level_bed_at_temp or
                           km.start_quad_gantry_level_at_temp or
                           km.start_z_tilt_adjust_at_temp or
                           (km.start_home_z_at_temp and not bed_at_target) %}
  {% set bed_overshoot = (BED + (km.start_bed_heat_overshoot if
             (BED and not bed_at_target) else 0.0),
           printer.configfile.settings.heater_bed.max_temp ) | min %}

  INIT_LAYER_GCODE LAYERS="{LAYERS}"
  {% if CHAMBER > 0.0 %}
    M141 S{CHAMBER}
  {% endif %}
  # Start bed heating
  M140 S{bed_overshoot}
  {% if actions_at_temp %}
    # If we're going to run a bed level we either have a probing temp specified
    # or we heat the extruder part way to avoid oozing while probing.
    M104 S{km.start_extruder_probing_temp if km.start_extruder_probing_temp > 0
      else (km.start_extruder_preheat_scale * EXTRUDER)|round(0,'ceil')|int}
  {% else %}
    # Honor the extruder probing temp, in case we just want to delay extruder
    # heating until after the bed is ready.
    M104 S{km.start_extruder_probing_temp if km.start_extruder_probing_temp > 0
      else EXTRUDER}
  {% endif %}
  # home all axes
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
  G28
  G90
  {% if BED > 0.0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=bed_heating RESET_STACK=1
    # Skip this if the bed was already at target when START_PRINT was called.
    {% if not bed_at_target %}
      PARK
      # Overshoot the target a bit.
      M190 S{bed_overshoot}
      G4 P{km.start_bed_heat_delay / 2}
      M190 R{BED} # Settle down after the overshoot.
      G4 P{km.start_bed_heat_delay / 2}
    {% endif %}
  {% endif %}

  {% if CHAMBER > 0.0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=chamber_heating RESET_STACK=1
    _KM_PARK_IF_NEEDED HEATER="chamber" RANGE=ABOVE
    M191 S{CHAMBER}
  {% endif %}

  {% if BED > 0.0 and bed_at_target%}
    M190 R{BED} # Extra bed stabilization if we skipped it earlier.
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="probing"

[gcode_macro _print_start_phase_probing]
description: Inserted by slicer at start of print. Performs probing (including
  mesh bed level) and other operations that should be run when the bed and
  chamber are stabilized at their target temps.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=probing
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set MESH_MIN = print.MESH_MIN|default(None) %}
  {% set MESH_MAX = print.MESH_MAX|default(None) %}
  # Randomize the placement of the print on the bed.
  {% if km.start_random_placement_max > 0 and print.PRINT_MIN and MESH_MIN %}
    {% set PRINT_MIN = print.PRINT_MIN.split(",")|map('float')|list %}
    {% set PRINT_MAX = print.PRINT_MAX.split(",")|map('float')|list %}
    {% set x_offset = (((km.print_max[0] - km.print_min[0] - PRINT_MAX[0] +
         PRINT_MIN[0] - 2 * km.start_random_placement_padding)|int,
         km.start_random_placement_max * 2)|min, 0)|max %}
    {% set y_offset = (((km.print_max[1] - km.print_min[1] - PRINT_MAX[1] +
         PRINT_MIN[1] - 2 * km.start_random_placement_padding)|int,
         km.start_random_placement_max * 2)|min, 0)|max %}
    {% if x_offset > 0 %}
      {% set x_offset = range(x_offset)|random + km.print_min[0] -
                          PRINT_MIN[0] + km.start_random_placement_padding %}
    {% endif %}
    {% if y_offset > 0 %}
      {% set y_offset = range(y_offset)|random + km.print_min[1] -
                          PRINT_MIN[1] + km.start_random_placement_padding %}
    {% endif %}
    # This MESH_MIN/MESH_MAX gets passed to BED_MESH_CALIBRATE below, but the
    # rest of the macros rely on SET_GCODE_OFFSET performing the adjustment.
    {% set MESH_MIN = MESH_MIN.split(",")|map('float')|list %}
    {% set MESH_MAX = MESH_MAX.split(",")|map('float')|list %}
    {% set MESH_MIN_NEW = (MESH_MIN[0] + x_offset, MESH_MIN[1] + y_offset) %}
    {% set MESH_MAX_NEW = (MESH_MAX[0] + x_offset, MESH_MAX[1] + y_offset) %}
    {action_respond_info(
       "Relocating print origin from (%.3f,%.3f) "|format(*MESH_MIN) +
       "to (%.3f,%.3f)"|format(*MESH_MIN_NEW))}
    {% set MESH_MIN = (MESH_MIN_NEW[0], MESH_MIN_NEW[1])|join(',') %}
    {% set MESH_MAX = (MESH_MAX_NEW[0], MESH_MAX_NEW[1])|join(',') %}
    PRINT_START_SET PRINT_OFFSET={"%d,%d" % (x_offset,y_offset)}
  {% endif %}

  {% set EXTRUDER = print.EXTRUDER|int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set start_level_bed_at_temp = km.start_level_bed_at_temp and
                                   not printer.bed_mesh.profile_name %}
  {% set start_home_z_at_temp = km.start_home_z_at_temp and
                                not print.BED_AT_TARGET|int %}
  {% set actions_at_temp = start_level_bed_at_temp or
                           km.start_quad_gantry_level_at_temp or
                           km.start_z_tilt_adjust_at_temp or
                           start_home_z_at_temp %}
  {% if actions_at_temp %}
    {% if km.start_extruder_probing_temp > 0 %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
      _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
      M109 R{km.start_extruder_probing_temp}
    {% else %}
      M104 S{EXTRUDER} # set the final extruder target temperature
    {% endif %}
    {% if km.start_z_tilt_adjust_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=calibrating_z RESET_STACK=1
      Z_TILT_ADJUST
    {% endif %}
    {% if km.start_quad_gantry_level_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=leveling_gantry RESET_STACK=1
      QUAD_GANTRY_LEVEL
    {% endif %}
    {% if start_home_z_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
      G28 Z # Re-home only the Z axis now that the bed has stabilized.
    {% endif %}
    {% if start_level_bed_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing RESET_STACK=1
      _km_mesh_if_needed {% if MESH_MIN %} MESH_MIN={MESH_MIN}{% endif
                       %}{% if MESH_MAX %} MESH_MAX={MESH_MAX}{% endif %}
    {% endif %}
    {% if km.start_extruder_probing_temp > 0 %}
      M104 S{EXTRUDER} # set the final extruder target temperature
    {% endif %}
    G4
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="extruder"

[gcode_macro _print_start_phase_extruder]
description: Inserted by slicer at start of print. Preheats the extruder.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=extruder
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set EXTRUDER = print.EXTRUDER|default(print.EXTRUDER_TEMP)|float %}
  {% set km = printer["gcode_macro _km_globals"] %}

  # Wait for extruder to reach temperature
  {% if EXTRUDER > 0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
    _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=ABOVE
    M109 S{EXTRUDER}
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="purge"

[gcode_macro _print_start_phase_purge]
description: Inserted by slicer at start of print. Generates purge lines.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=purge
  # Apply the offset for bed placement randomization.
  _KM_APPLY_PRINT_OFFSET
  # apply Z offset for bed surface (just in case it was reset).
  _APPLY_BED_SURFACE_OFFSET
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set MESH_MIN = print.MESH_MIN|default(None) %}
  {% set MESH_MAX = print.MESH_MAX|default(None) %}
  {% set NOZZLE_SIZE = print.NOZZLE_SIZE|default(print.NOZZLE_SIZE)|
         default(printer.configfile.settings.extruder.nozzle_diameter)|float %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if km.start_purge_length > 0.0 and printer.extruder.can_extrude %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=purging RESET_STACK=1
    DRAW_PURGE_LINE WIDTH="{NOZZLE_SIZE * 1.25}" HEIGHT="{NOZZLE_SIZE * 0.625
                    }"{% if MESH_MIN %} PRINT_MIN={MESH_MIN}{% endif
                    %}{% if MESH_MAX %} PRINT_MAX={MESH_MAX}{% endif %}
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="printing"
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=printing RESET_STACK=1

[gcode_macro _km_park_if_needed]
description: Parks the extruder if the current temperature of the supplied
  heater is not within the specified target range.
  Usage: _KM_PARK_IF_NEEDED HEATER=<heater> RANGE=[<percentage>|ABOVE|BELOW]
gcode:
  # This needs to get called as its own macro to get the current temp evaluated.
  {% set HEATER = params.HEATER if params.HEATER in
                    printer.heaters.available_heaters else
                  ("heater_generic " ~ params.HEATER) %}
  {% set RANGE = (params.RANGE|default(1))|string|upper %}

  {% if printer[HEATER].target %}
    {% if RANGE == "ABOVE" %}
      {% if printer[HEATER].temperature < printer[HEATER].target %}
        PARK
      {% endif %}
    {% elif RANGE == "BELOW" %}
      {% if printer[HEATER].temperature > printer[HEATER].target %}
        PARK
      {% endif %}
    {% elif (printer[HEATER].temperature - printer[HEATER].target)|abs >
             (printer[HEATER].target * RANGE|float * 0.01)|abs %}
      PARK
    {% endif %}
  {% endif %}

[gcode_macro _km_apply_print_offset]
variable_offset: []
gcode:
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% if params.RESET|default(0)|int and offset and
        not printer["gcode_macro _km_save_state"].is_ephemeral%}
    {% set PRINT_OFFSET = [offset.pop(0) * -1, offset.pop() * -1] %}
  {% elif print.PRINT_OFFSET and not offset and
          not printer["gcode_macro _km_save_state"].is_ephemeral %}
    {% set PRINT_OFFSET = print.PRINT_OFFSET.split(",")|map('float')|list %}
    {% set dummy = offset.extend(PRINT_OFFSET) %}
  {% endif %}

  {% if PRINT_OFFSET %}
    _KM_SET_GCODE_OFFSET_BASE {"X_ADJUST=%.2f Y_ADJUST=%.2f"|
                                  format(*PRINT_OFFSET)}
  {% endif %}

[gcode_macro _km_mesh_if_needed]
gcode:
  # TODO: Instead of blindly using the loaded mesh we could probe a few key
  # points on the saved grid. If those probes show that the saved grid is no
  # longer in tolerance we could just run BED_MESH_CALIBRATE_FAST anyway.
  {% if not printer.bed_mesh.profile_name %}
    BED_MESH_CALIBRATE_FAST {rawparams}
  {% endif %}

[gcode_macro print_start_set]
description: Inserted by slicer to set values used by PRINT_START.
  Usage: PRINT_START_SET <VARIABLE>=<value>
variable_print: {}
gcode:
  {%for k in params %}
    {% set dummy = print.__setitem__(k|upper, params[k]) %}
  {% endfor %}

[gcode_macro _print_start_phase_check]
gcode:
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set PRINT_START_PHASE = print.PRINT_START_PHASE|default("none") %}
  {% if PRINT_START_PHASE != params.PHASE %}
    # Reset the phases manually just to be sure.
    SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
    {% if params.PHASE != 'none' %}
      {% set error = "PRINT_START phase error. Expected '%s' but found '%s'" %
                       (params.PHASE, PRINT_START_PHASE) %}
      # Do the cancel manually if we're not confident it will fire.
      {% if not 'virtual_sdcard' in printer or
            not printer.virtual_sdcard.is_active or 'CANCEL_PRINT' not in
              printer.configfile.settings.virtual_sdcard.on_error_gcode|
                default("")|upper %}
        {action_respond_info(error)}
        CANCEL_PRINT
      {% else %}
        {action_raise_error(error)}
      {% endif %}
    {% else %}
      { action_respond_info("Expected phase '%s' but found '%s'. Resetting."
                             % (params.PHASE, PRINT_START_PHASE)) }
    {% endif %}
  {% endif %}

[gcode_macro print_end]
description: Inserted by slicer at end of print.
  Usage: PRINT_END
gcode:
  _KM_CHECK_IS_PRINTING
  M400
  _PRINT_END_INNER

  {% set km = printer["gcode_macro _km_globals"] %}

  {% if km.start_clear_adjustments_at_end != 0 %}
    RESET_HEATER_SCALING
    RESET_FAN_SCALING
    M220 S100
    M221 S100
  {% endif %}
  _RESET_LAYER_GCODE
  _RESET_VELOCITY_LIMITS
  TURN_OFF_HEATERS
  M107; turn off fan
  {% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
  # Park the toolhead and present the bed
  {% if printer.toolhead.homed_axes|lower == "xyz" %}
    PARK Y="{km.start_end_park_y}"
  {% endif %}
  M84 ; disable steppers
  CLEAR_PAUSE
  SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=ready RESET_STACK=1

[gcode_macro _print_end_inner]
variable_cancelled: False
gcode:
  SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set toolhead = printer.toolhead %}
  {% set origin = printer.gcode_move.homing_origin%}
  {% set max_x = km.print_max[0] - origin.x %}
  {% set max_y = km.print_max[1] - origin.y %}
  {% set max_z = toolhead.axis_maximum.z - origin.z %}

  {% if not cancelled %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=completing
  {% endif %}

  {% if printer.extruder.can_extrude %}
    # Wipe if we're not cancelling a paused print.
    {% if not printer.pause_resume.is_paused and not cancelled and
          toolhead.homed_axes|lower == "xyz" %}
      {% set x_safe = (max_x - toolhead.position.x, 2.0)|min %}
      {% set y_safe = (max_y - toolhead.position.y, 2.0)|min %}
      {% set z_safe = (max_z - toolhead.position.z, 2.0)|min %}
      G91
      G0 Z{z_safe} E-1.0 F{km.travel_speed_z * 2} ; move nozzle up
      G0 X{x_safe} Y{y_safe} E-1.0 F{km.travel_speed_xy} ; remove stringing
      # Remove the offset now that we're done.
      _KM_APPLY_PRINT_OFFSET RESET=1
    {% endif %}

    # Small retract to prevent ooze
    G92 E0
    G1 E{"%.2f" % ((0, 2 - km.load_priming_length / 4)|min)} F1200
    M400
  {% endif %}

[gcode_macro _km_check_is_printing]
variable_debug_state: False # Disables print state check for debugging.
description: Throws an error if print is not currently in progress.
gcode:
  {% if not debug_state and
        printer.idle_timeout.state|string != "Printing" and
        not (printer.virtual_sdcard|default({})).is_active|default(False) and
        not printer.pause_resume.is_paused %}
    { action_raise_error("No active print.") }
  {% endif %}

[gcode_macro _km_check_and_set_print_bounds]
description: Validates all print bounds and caches their values.
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set print = printer["gcode_macro print_start_set"].print %}

  # Check the mesh bounds.
  {% if print.MESH_MIN %}
    {% set MESH_MIN = print.MESH_MIN.split(",")|map('float')|list %}
    {% set MESH_MAX = print.MESH_MAX.split(",")|map('float')|list %}
    {%if MESH_MIN[0] < km.print_min[0] or MESH_MIN[1] < km.print_min[1] %}
      {action_raise_error("MESH_MIN %s is outside the printable bounds %s" %
                            (MESH_MIN|string, km.print_min|string))}
    {%elif MESH_MAX[0] > km.print_max[0] or MESH_MAX[1] > km.print_max[1] %}
      {action_raise_error("MESH_MAX %s is outside the printable bounds %s" %
                            (MESH_MAX|string, km.print_max|string))}
    {% endif %}
  {% endif %}

  # Find all the model bounds (including any bounds passed in).
  {% set points = [] %}
  {% if print.MODEL_MIN or print.MODEL_MAX %}
    {% set MODEL_MIN = print.MODEL_MIN.split(",")|map('float')|list %}
    {% set MODEL_MAX = print.MODEL_MAX.split(",")|map('float')|list %}
    {% set points = [MODEL_MIN, MODEL_MAX] %}
  {% endif %}
  {% if (printer.exclude_object|default({})).objects %}
    {% set points = printer.exclude_object.objects|selectattr('polygon')|
                      map(attribute='polygon')|sum(start=points) %}
    {% set points_len = points|length %}
    {% if points_len >= 2 %}
      {% set x_coords = (points|map(attribute=0)|sort|list)[0::points_len-1] %}
      {% set y_coords = (points|map(attribute=1)|sort|list)[0::points_len-1] %}
      {% set MODEL_MIN = (x_coords[0],y_coords[0])|map('float')|list %}
      {% set MODEL_MAX = (x_coords[1],y_coords[1])|map('float')|list %}
      PRINT_START_SET MODEL_MIN="{MODEL_MIN|join(',')
                   }" MODEL_MAX="{MODEL_MAX|join(',')}"
    {% endif %}
  {% endif %}

  {% if MODEL_MIN %}
    # Check the model bounds.
    {% if MODEL_MIN[0] < km.print_min[0] or MODEL_MIN[1] < km.print_min[1] %}
      {action_raise_error("MODEL_MIN %s is outside the printable bounds %s" %
                            (MODEL_MIN|string, km.print_min|string))}
    {% elif MODEL_MAX[0] > km.print_max[0] or MODEL_MAX[1] > km.print_max[1] %}
      {action_raise_error("MODEL_MAX %s is outside the printable bounds %s" %
                            (MODEL_MAX|string, km.print_max|string))}
    {% endif %}
  {% endif %}

  # Set the PRINT_LIMITS
  {% if MESH_MIN and MODEL_MIN %}
    PRINT_START_SET PRINT_MIN="{((MODEL_MIN[0],MESH_MIN[0])|min,
                                 (MODEL_MIN[1],MESH_MIN[1])|min)|join(',')
                  }" PRINT_MAX="{((MODEL_MAX[0],MESH_MAX[0])|max,
                                  (MODEL_MAX[1],MESH_MAX[1])|max)|join(',')}"
  {% else %}
    PRINT_START_SET PRINT_MIN="{km.print_min|join(',')
                 }" PRINT_MAX="{km.print_max|join(',')}"
  {% endif %}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _km_save_state]
description: Tracks gcode state.
variable_state_set: {}
variable_is_ephemeral: 0
gcode:
  {% if params.SAVE|int %}
    {% set dummy = state_set.__setitem__(params.NAME, None) %}
  {% else %}
    {% set dummy = state_set.__delitem__(params.NAME) %}
  {% endif %}
  SET_GCODE_VARIABLE MACRO=_km_save_state VARIABLE=is_ephemeral VALUE="{
    1 if state_set|length > 0 else 0 }"

[gcode_macro save_gcode_state]
description: Wraps SAVE_GCODE_STATE to track persistence state.
  Usage: See Klipper documentation
rename_existing: _KM_SAVE_GCODE_STATE
gcode:
  _KM_SAVE_GCODE_STATE {rawparams}
  {% set NAME = params.NAME|default("default") %}
  _km_save_state NAME={NAME} SAVE=1

[gcode_macro restore_gcode_state]
description: Wraps RESTORE_GCODE_STATE to track persistence state.
  Usage: See Klipper documentation
rename_existing: _KM_RESTORE_GCODE_STATE
gcode:
  _KM_RESTORE_GCODE_STATE {rawparams}
  {% set NAME = params.NAME|default("default") %}
  _km_save_state NAME={NAME} SAVE=0

[gcode_macro _abort_on_gcode_state]
gcode:
  {% set save_state = printer["gcode_macro _km_save_state"] %}
  {% if save_state.is_ephemeral %}
    {action_raise_error("Encountered unexpected save state " +
                          save_state.state_set|list|sort|string)}
  {% endif %}

# Copyright (C) 2023 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.


[gcode_macro _km_print_status]
variable_last_status: 'none'
variable_status_stack: []
variable_command_list: {}
variable_status_list: [
  'ready', # Printer is ready to receive a job
  'filament_load', # Loading filament
  'filament_unload', # Unloading filament
  'bed_heating', # Waiting for the bed to reach target
  'chamber_heating', # Waiting for the chamber to reach target
  'homing', # Homing any axis
  'leveling_gantry', # Performing quad gantry-leveling
  'calibrating_z', # Performing z-tilt adjustment
  'meshing', # Calibrating a bed mesh
  'extruder_heating', # Waiting for the extruder to reach target
  'purging', # Printing purge line
  'printing', # Actively printing
  'pausing', # Print is paused
  'cancelling', # Print is being cancelled
  'completing', # Print completed
  ]
gcode:
  {% set ACTION = params.ACTION|trim|upper %}
  {% set STATUS = params.STATUS|default("")|trim|lower %}

  # Add a status handler.
  {% if ACTION == "ADD_EVENT" %}
    {% set COMMAND = params.COMMAND %}
    {% set ARGS = params.ARGS|default(0)|int != 0 %}
    {% set TYPE = params.TYPE|default('ENTER')|trim|upper %}
    {% set WHEN = params.WHEN|default('PRINTING')|trim|upper %}
    {% set FILTER_ENTER =
             (params.FILTER_ENTER|default("")|trim|lower).split(',')|
               select()|unique|list %}
    {% set FILTER_LEAVE =
             (params.FILTER_LEAVE|default("")|trim|lower).split(',')|
               select()|unique|list %}

    {% set STATUSES = STATUS.split(',')|map('trim')|list %}
    {% for s in (STATUSES if STATUSES[0] != 'all' else status_list) %}
      {% if not s in command_list %}
        {% set dummy = command_list.__setitem__(s,[]) %}
      {% endif %}
      {% set dummy = command_list[s].append({'cmd':COMMAND, 'args':ARGS,
                                             'type':TYPE, 'when':WHEN,
                                             'filt_e':FILTER_ENTER,
                                             'filt_l':FILTER_LEAVE}) %}
    {% endfor %}

  # Change the current status.
  {% elif ACTION == "CHANGE" %}
    {% if params.RESET_STACK|default(0)|int %}
      {% for dummy in range(status_stack|length) %}
        {% set dummy = status_stack.pop() %}
      {% endfor %}
      # TODO: Once python 3 is required, switch the for loop above to this:
      #{% set dummy = status_stack.clear() %}
    {% elif STATUS == "pop_status" %}
      {% set STATUS = (status_stack|default(['ready'], True)).pop() %}
    {% endif %}

    {% if STATUS not in status_list %}
      {action_raise_error("Status '%s' not valid."|format(STATUS))}
    {% endif %}

    {% if STATUS != last_status %}
      {% set is_printing =
           printer["gcode_macro print_start_set"].print.PRINT_START_PHASE|
             default("")|length != 0 %}
      {% set print_states = ('ALWAYS', 'PRINTING' if is_printing else 'IDLE') %}
      # Process commands for the state we're leaving first.
      {% for c in command_list[last_status]|default([]) %}
        {% if c.type in ('BOTH','LEAVE') and c.when in print_states and
              (not c.filt_l or STATUS in c.filt_l) %}
          M400
          {c.cmd}{% if c.args %} TYPE=LEAVE WHEN={print_states[1]
            } LAST_STATUS={last_status} NEXT_STATUS={STATUS}{% endif %}
        {% endif %}
      {% endfor %}
      # Process commands for the state we're entering last.
      {% for c in command_list[STATUS]|default([]) %}
        {% if c.type in ('BOTH','ENTER') and c.when in print_states and
              (not c.filt_e or STATUS in c.filt_e) %}
          M400
          {c.cmd}{% if c.args %} TYPE=ENTER WHEN={print_states[1]
            } LAST_STATUS={last_status} NEXT_STATUS={STATUS}{% endif %}
        {% endif %}
      {% endfor %}
      SET_GCODE_VARIABLE MACRO=_km_print_status VARIABLE=last_status VALUE="'{
        STATUS}'"
    {% endif %}

  # Push the current status onto the stack.
  {% elif ACTION == "PUSH_STATUS" %}
    {% set dummy = status_stack.append(last_status) %}

  # Illegal operation.
  {% else %}
    {action_raise_error("Action '%s' not valid."|format(ACTION))}
  {% endif %}

[gcode_macro gcode_on_print_status]
description: Adds a gcode command for a status event.
  Usage: GCODE_ON_PRINT_STATUS STATUS=<status> COMMAND=<gcode> [ARGS=<1|0>]
                               [WHEN=<PRINTING|IDLE|ALWAYS>]
                               [TYPE=<ENTER|LEAVE|BOTH>]
                               [FILTER_ENTER=<status list>]
                               [FILTER_LEAVE=<status list>]
gcode:
  {% set STATUS = (params.STATUS|lower).split(',')|map('trim')|list %}
  {% set TYPE = params.TYPE|default('ENTER')|trim|upper %}
  {% set WHEN = params.WHEN|default('PRINTING')|trim|upper %}
  {% set FILTER_ENTER =
       (params.FILTER_ENTER|default("")|trim|lower).split(',')|select()|list %}
  {% set FILTER_LEAVE =
       (params.FILTER_LEAVE|default("")|trim|lower).split(',')|select()|list %}

  # Error checking
  {% set status_list = printer["gcode_macro _km_print_status"].status_list %}
  {% for s in STATUS %}
    {% if not (s in status_list or s == 'all' and STATUS|length == 1) %}
      {action_raise_error("STATUS parameter '%s' not valid."|format(s))}
    {% endif %}
  {% endfor %}

  {% if TYPE not in ('ENTER', 'LEAVE', 'BOTH') %}
    {action_raise_error("TYPE paramater '%s' not valid."|format(TYPE))}
  {% elif WHEN not in ('PRINTING', 'IDLE', 'ALWAYS') %}
    {action_raise_error("WHEN parameter '%s' not valid."|format(WHEN))}
  {% elif TYPE == 'ENTER' and FILTER_LEAVE %}
    {action_raise_error("FILTER_LEAVE not valid with TYPE=ENTER.")}
  {% elif TYPE == 'LEAVE' and FILTER_ENTER %}
    {action_raise_error("FILTER_ENTER not valid with TYPE=LEAVE.")}
  {% endif %}
  {% for f in FILTER_ENTER %}
    {% if f not in status_list %}
      {action_raise_error("FILTER_ENTER parameter '%s' not valid."|format(f))}
    {% endif %}
  {% endfor %}
  {% for f in FILTER_LEAVE %}
    {% if f not in status_list %}
      {action_raise_error("FILTER_LEAVE parameter '%s' not valid."|format(f))}
    {% endif %}
  {% endfor %}

  # Run the command.
  _KM_PRINT_STATUS ACTION=ADD_EVENT {rawparams}

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro m201]
description: Sets maximum accelleration.
  Usage: M201 [X<accel>] [Y<accel>]
variable_max_accel: 1.7976931348623157e+308
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if 'X' in params or 'Y' in params %}
    {% set accel = (params.X|default(params.Y)|float,
                    params.Y|default(params.X)|float)|min %}
    SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{accel}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m203]
description: Sets maximum velocity.
  Usage: M203 [X<velocity>] [Y<velocity>]
gcode:
  {% if 'X' in params or 'Y' in params %}
    {% set velocity = (params.X|default(params.Y)|float,
                       params.Y|default(params.X)|float)|min %}
    SET_VELOCITY_LIMIT VELOCITY="{velocity}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m205]
description: Sets square corner velocity.
  Usage: M203 [X<velocity>] [Y<velocity>]
gcode:
  {% if 'X' in params or 'Y' in params %}
    SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY="{
      (params.X|default(0)|float, params.Y|default(0)|float)|min}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m900]
description: Sets pressure advance.
  Usage: M900 [K<advance>] [T<extruder_index>]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if km.pressure_advance_scale > 0.0 %}
    {% set extruder = "extruder" ~ params.T|replace('0', '')
       if "T" in params else printer.toolhead.extruder %}
    {% if 'K' in params %}
      SET_PRESSURE_ADVANCE EXTRUDER="{extruder}" ADVANCE="{
        params.K|float * km.pressure_advance_scale}"
    {% endif %}
  {% endif %}


[gcode_macro _reset_velocity_limits]
description: Sets maximum accelleration.
  Usage: M204 [S<accel>] [P<accel> T<accel>]
gcode:
  SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{1.7976931348623157e+308}"

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro bed_mesh_calibrate]
rename_existing: _KM_BED_MESH_CALIBRATE_BASE
description: Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
  Usage: See Klipper documentation.
gcode:
  BED_MESH_CALIBRATE_FAST{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}

[gcode_macro g29]
gcode:
  BED_MESH_CALIBRATE

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

################################################################################
# Existing menu refinements.
################################################################################

# Hide unused menus

#[menu __main __octoprint]
#type: list
#name: OctoPrint
#enable: {printer["gcode_macro _km_globals"].menu_show_octoprint}


# Get the file list out of the SD card menu while printing.
[menu __main __sdcard]
type: list
enable: {'virtual_sdcard' in printer and
         printer["gcode_macro _km_globals"].menu_show_sdcard}
name: SD Card

[menu __main __sdcard __start]
type: command
enable: {printer.virtual_sdcard.file_path and
         not printer.virtual_sdcard.is_active and
         printer.print_stats.state != "printing" and
         printer.print_stats.state != "paused"}
name: Print: {printer.virtual_sdcard.file_path.split('/')|last}
gcode:
  M24
  {menu.back()}

[menu __main __sdcard __select]
type: vsdlist
enable: {not printer.virtual_sdcard.is_active and
         printer.print_stats.state != "printing" and
         printer.print_stats.state != "paused"}
name: Select file
index: 1

[menu __main __sdcard __select __start]
type: command
enable: {printer.virtual_sdcard.file_path and
         not printer.virtual_sdcard.is_active}
name: Print: {printer.virtual_sdcard.file_path.split('/')|last}
gcode:
  M24
  {menu.back()}

[menu __main __setup __calib __delta_calib_auto]
type: command
enable: {'delta_calibrate' in printer.configfile.settings and
         not printer.idle_timeout.state == "Printing"}
name: Delta cal. auto
gcode:
    G28
    DELTA_CALIBRATE

[menu __main __setup __calib __delta_calib_man]
type: list
enable: {'delta_calibrate' in printer.configfile.settings and
         not printer.idle_timeout.state == "Printing"}
name: Delta cal. man

# Require confirmation for anything that would abort an in-progress print.

# Steppers off
[menu __main __control __disable]
type: command
name: Steppers off
enable: {printer.idle_timeout.state != "Printing"}
gcode:
  M84
  M18

[menu __main __control __disable_printing]
type: list
index: 3
enable: {printer.idle_timeout.state == "Printing"}
name: Steppers off

[menu __main __control __disable_printing __confirm]
type: command
name: Confirm steppers off
gcode:
  M84
  M18
  {menu.back()}

# Add a park menu item.
[menu __main __control __park]
type: command
name: Park toolhead
enable: {printer.idle_timeout.state != "Printing" or
         printer.pause_resume.is_paused}
index: 1
gcode:
  PARK LAZY=1

# Octoprint abort
[menu __main __octoprint __abort]
type: list
enable: {printer.idle_timeout.state == "Printing"}
name: Abort printing

[menu __main __octoprint __abort __confirm]
type: command
name: Confirm abort printing
gcode:
  {action_respond_info('action:cancel')}
  {menu.back()}

# SD card cancel
[menu __main __sdcard __cancel]
type: list
enable: {('virtual_sdcard' in printer) and
         (printer.print_stats.state == "printing" or
          printer.print_stats.state == "paused")}
name: Cancel printing

[menu __main __sdcard __cancel __confirm]
type: command
name: Confirm cancel printing
gcode:
  {% if 'pause_resume' in printer %}
    CANCEL_PRINT
  {% else %}
    M25
    M27
    M26 S0
    TURN_OFF_HEATERS
    G91
    G0 Z{(printer.toolhead.position.z, printer.toolhead.axis_maximum.z - 5)|min
        } F1000
    G90
  {% endif %}
  {menu.back()}

# Extra setup menu options

# Shutdown and reboot
[menu __main __setup __restart]
type: list
name: Host Control

[menu __main __setup __restart __reboot]
type: command
name: Reboot host
gcode:
  M117 Rebooting host
  M118 Rebooting host
  {menu.exit()}
  G4 S2 ; Let the user see the console message.
  {action_call_remote_method("reboot_machine")} ; Try Moonraker.
  G4 S1 ; give Moonraker a chance to finish.
  {action_respond_info('action:poweroff')} ; Try Octoprint.

[menu __main __setup __restart __shutdown]
type: command
name: Shutdown host
gcode:
  M117 Shutting down
  M118 Shutting down
  {menu.exit()}
  G4 S2 ; Let the user see the console message.
  {action_call_remote_method("shutdown_machine")} ; Try Moonraker.
  G4 S1 ; give Moonraker a chance to finish.
  {action_respond_info('action:poweroff')} ; Try Octoprint.

# Speed and flow
[menu __main __setup __speed]
type: input
name: Speed: {'%3d' % (menu.input*100)}%
input: {printer.gcode_move.speed_factor}
input_min: 0.01
input_max: 5
input_step: 0.01
realtime: True
index: 4
gcode:
    M220 S{'%d' % (menu.input*100)}

[menu __main __setup __flow]
type: input
name: Flow: {'%3d' % (menu.input*100)}%
input: {printer.gcode_move.extrude_factor}
input_min: 0.01
input_max: 2
input_step: 0.01
realtime: True
index: 5
gcode:
    M221 S{'%d' % (menu.input*100)}

################################################################################
# Replace filament loading with our own macros.
################################################################################

[menu __main __filament]
type: list
name: Filament
enable: {printer.idle_timeout.state != "Printing" or
         printer.pause_resume.is_paused}

# Hide the old load/unload commands.
[menu __main __filament __loadf]
type: command
name: Load Fil. fast
enable: False

[menu __main __filament __loads]
type: command
name: Load Fil. slow
enable: False

[menu __main __filament __unloadf]
type: command
name: Unload Fil.fast
enable: False

[menu __main __filament __unloads]
type: command
name: Unload Fil.slow
enable: False

# Add new load/unload using our macros.
[menu __main __filament __load]
type: command
index: 1
name: Load Filament
gcode:
  LOAD_FILAMENT

[menu __main __filament __unload]
type: command
index: 2
name: Unload Filament
gcode:
  UNLOAD_FILAMENT

[menu __main __filament __feed]
type: input
name: Feed: {'%.1f' % menu.input}
input: 0.0
input_min: -50.0
input_max: 50.0
input_step: 1.0
gcode:
  SAVE_GCODE_STATE NAME=_KM_FILAMENT_LOAD
  M83
  G1 E{'%.1f' % menu.input
   } F{printer["gcode_macro _km_globals"].load_priming_speed}
  RESTORE_GCODE_STATE NAME=_KM_FILAMENT_LOAD

################################################################################
# Layer triggers.
################################################################################

[menu __main __sdcard __pause_layer]
type: input
index: 4
enable: {('virtual_sdcard' in printer) and
         printer.print_stats.state == "printing"}
name: Pause {% set layer = printer.print_stats.info.current_layer %}{%
               if layer >= menu.input|int %}layer{%
               elif layer + 1 == menu.input|int %}at: next{%
               else %}at: {menu.input|int}{% endif %}
input: {printer.print_stats.info.current_layer}
input_min: {printer.print_stats.info.current_layer}
input_max: {printer.print_stats.info.total_layer}
input_step: 1
gcode:
  {% if menu.input|int > printer.print_stats.info.current_layer %}
    PAUSE_AT_LAYER LAYER={menu.input}
  {% endif %}

[menu __main __octoprint __pause_layer]
type: input
index: 1
enable: {printer.idle_timeout.state == "Printing"}
name: Pause {% set layer = printer.print_stats.info.current_layer %}{%
               if layer >= menu.input|int %}layer{%
               elif layer + 1 == menu.input|int + 1 %}at: next{%
               else %}at: {menu.input|int}{% endif %}
input: {printer.print_stats.info.current_layer}
input_min: {printer.print_stats.info.current_layer}
input_max: {printer.print_stats.info.total_layer}
input_step: 1
gcode:
  {% if menu.input|int > printer.print_stats.info.current_layer %}
    GCODE_AT_LAYER LAYER={menu.input|int
                 } COMMAND="RESPOND TYPE=command MSG=action:pause"
  {% endif %}

################################################################################
# Bed surface.
################################################################################

[menu __main __setup __bed_surface]
type: input
name: Bed: {(printer.save_variables.variables.bed_surfaces.available
             | list | sort)[menu.input|int]}
input: {% set surfaces = printer.save_variables.variables.bed_surfaces
         %}{(surfaces.available | list | sort).index(surfaces.active) | int}
input_min: 0
input_max: {((printer.save_variables.variables.bed_surfaces.available
              | length) - 1)}
input_step: 1
index: 4
gcode:
  SET_SURFACE_ACTIVE SURFACE={
      (printer.save_variables.variables.bed_surfaces.available
       | list | sort)[menu.input|int]}

[menu __main __setup __offsetz]
type: input
name: Offset Z:{ '%05.3f' % menu.input }
input: {% set surfaces = printer.save_variables.variables.bed_surfaces
         %}{ surfaces.available[surfaces.active].offset | float }
input_min: -5
input_max: 5
input_step: 0.005
index: 5
realtime: True
gcode:
  SET_SURFACE_OFFSET OFFSET={menu.input}

[menu __main __tune __offsetz]
type: input
name: Offset Z:{ '%05.3f' % menu.input }
input: { printer.gcode_move.homing_origin.z }
input_min: -5
input_max: 5
input_step: 0.005
realtime: True
gcode:
  SET_SURFACE_OFFSET OFFSET={menu.input}

################################################################################
# Heater overrides.
################################################################################

### menu temperature ###

# Hide the original menu
[menu __main __temp]
type: list
name: Temperature
enable: False

[menu __main __temp_km]
type: list
name: Temperature
index: 4

[menu __main __temp_km __hotend0_target]
type: input
enable: {'extruder' in printer}
name: {"Ex0:%3.0f (%4.0f)" % (menu.input, printer.extruder.temperature)}
input: {printer.extruder.target}
input_min: 0
input_max: {printer.configfile.config.extruder.max_temp}
input_step: 1
gcode: SET_HEATER_TEMPERATURE HEATER=extruder TARGET={'%.0f' % menu.input}

[menu __main __temp_km __hotend1_target]
type: input
enable: {'extruder1' in printer}
name: {"Ex1:%3.0f (%4.0f)" % (menu.input, printer.extruder1.temperature)}
input: {printer.extruder1.target}
input_min: 0
input_max: {printer.configfile.config.extruder1.max_temp}
input_step: 1
gcode: SET_HEATER_TEMPERATURE HEATER=extruder1 TARGET={'%.0f' % menu.input}

[menu __main __temp_km __hotbed_target]
type: input
enable: {'heater_bed' in printer}
name: {"Bed:%3.0f (%4.0f)" % (menu.input, printer.heater_bed.temperature)}
input: {printer.heater_bed.target}
input_min: 0
input_max: {printer.configfile.config.heater_bed.max_temp}
input_step: 1
gcode: SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={'%.0f' % menu.input}

# We just create 10 preheat placeholders below, and dynamically enable and fill
# them in from the dictionary in variable_menu_temperature.

## Pre-heat [0] ##
[menu __main __temp_km __preheat_0]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[0].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 0}

[menu __main __temp_km __preheat_0 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[0] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[0] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_0 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[0]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[0].extruder}

[menu __main __temp_km __preheat_0 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[0]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[0].bed}

[menu __main __temp_km __preheat_0 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[0]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[0].chamber}

## Pre-heat [1] ##
[menu __main __temp_km __preheat_1]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[1].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 1}

[menu __main __temp_km __preheat_1 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[1] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[1] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_1 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[1]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[1].extruder}

[menu __main __temp_km __preheat_1 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[1]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[1].bed}

[menu __main __temp_km __preheat_1 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[1]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[1].chamber}

## Pre-heat [2] ##
[menu __main __temp_km __preheat_2]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[2].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 2}

[menu __main __temp_km __preheat_2 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[2] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[2] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_2 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[2]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[2].extruder}

[menu __main __temp_km __preheat_2 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[2]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[2].bed}

[menu __main __temp_km __preheat_2 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[2]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[2].chamber}

## Pre-heat [3] ##
[menu __main __temp_km __preheat_3]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[3].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 3}

[menu __main __temp_km __preheat_3 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[3] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[3] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_3 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[3]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[3].extruder}

[menu __main __temp_km __preheat_3 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[3]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[3].bed}

[menu __main __temp_km __preheat_3 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[3]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[3].chamber}

## Pre-heat [4] ##
[menu __main __temp_km __preheat_4]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[4].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 4}

[menu __main __temp_km __preheat_4 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[4] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[4] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_4 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[4]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[4].extruder}

[menu __main __temp_km __preheat_4 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[4]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[4].bed}

[menu __main __temp_km __preheat_4 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[4]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[4].chamber}

## Pre-heat [5] ##
[menu __main __temp_km __preheat_5]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[5].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 5}

[menu __main __temp_km __preheat_5 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[5] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[5] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_5 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[5]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[5].extruder}

[menu __main __temp_km __preheat_5 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[5]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[5].bed}

[menu __main __temp_km __preheat_5 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[5]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[5].chamber}

## Pre-heat [6] ##
[menu __main __temp_km __preheat_6]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[6].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 6}

[menu __main __temp_km __preheat_6 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[6] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[6] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_6 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[6]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[6].extruder}

[menu __main __temp_km __preheat_6 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[6]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[6].bed}

[menu __main __temp_km __preheat_6 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[6]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[6].chamber}

## Pre-heat [7] ##
[menu __main __temp_km __preheat_7]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[7].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 7}

[menu __main __temp_km __preheat_7 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[7] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[7] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_7 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[7]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[7].extruder}

[menu __main __temp_km __preheat_7 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[7]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[7].bed}

[menu __main __temp_km __preheat_7 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[7]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[7].chamber}

## Pre-heat [8] ##
[menu __main __temp_km __preheat_8]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[8].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 8}

[menu __main __temp_km __preheat_8 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[8] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[8] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_8 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[8]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[8].extruder}

[menu __main __temp_km __preheat_8 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[8]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[8].bed}

[menu __main __temp_km __preheat_8 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[8]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[8].chamber}

## Pre-heat [9] ##
[menu __main __temp_km __preheat_9]
type: list
name: Preheat {printer["gcode_macro _km_globals"].menu_temperature[9].name}
enable: {printer.idle_timeout.state != "Printing" and
         printer["gcode_macro _km_globals"].menu_temperature|length > 9}

[menu __main __temp_km __preheat_9 __all]
type: command
enable: {printer["gcode_macro _km_globals"].menu_temperature[9] | list |
           select('in', ['extruder', 'bed', 'chamber']) | list | length > 1 and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Preheat all
gcode:
  {% set targets = printer["gcode_macro _km_globals"].menu_temperature[9] %}
  {% if 'chamber' in targets and
        'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET={targets.chamber}
  {% endif %}
  {% if 'bed' in targets and 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={targets.bed}
  {% endif %}
  {% if 'extruder' in targets and 'extruder' in printer %}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
      targets.extruder}
  {% endif %}

[menu __main __temp_km __preheat_9 __hotend]
type: command
enable: {'extruder' in printer and
         'extruder' in printer["gcode_macro _km_globals"].menu_temperature[9]}
name: Preheat hotend
gcode:
  SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[9].extruder}

[menu __main __temp_km __preheat_9 __hotbed]
type: command
enable: {'heater_bed' in printer and
         'bed' in printer["gcode_macro _km_globals"].menu_temperature[9]}
name: Preheat bed
gcode:
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[9].bed}

[menu __main __temp_km __preheat_9 __chamber]
type: command
enable: {'heater_generic chamber' in printer.heaters.available_heaters and
         'chamber' in printer["gcode_macro _km_globals"].menu_temperature[9]}
name: Preheat chamber
gcode:
  SET_HEATER_TEMPERATURE HEATER=chamber TARGET={
    printer["gcode_macro _km_globals"].menu_temperature[9].chamber}

## Cooldown ##
[menu __main __temp_km __cooldown_all]
type: command
enable: {printer.idle_timeout.state != "Printing" and
         (('extruder' in printer) + ('heater_bed' in printer) +
          ('heater_generic chamber' in printer.heaters.available_heaters)) > 1}
name: Cooldown all
gcode:
  {% if 'heater_generic chamber' in printer.heaters.available_heaters %}
    SET_HEATER_TEMPERATURE HEATER=chamber TARGET=0
  {% endif %}
  {% if 'heater_bed' in printer %}
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET=0
  {% endif %}
  {% if 'extruder' in printer%}
    SET_HEATER_TEMPERATURE HEATER={printer.toolhead.extruder} TARGET=0
  {% endif %}

[menu __main __temp_km __cooldown_hotend]
type: command
enable: {printer.idle_timeout.state != "Printing" and 'extruder' in printer}
name: Cooldown hotend
gcode: M104 S0

[menu __main __temp_km __cooldown_hotbed]
type: command
enable: {printer.idle_timeout.state != "Printing" and 'heater_bed' in printer}
name: Cooldown bed
gcode: M140 S0

[menu __main __temp_km __cooldown_chamber]
type: command
enable: {printer.idle_timeout.state != "Printing" and
         'heater_generic chamber' in printer.heaters.available_heaters}
name: Cooldown chamber
gcode: M141 S0
